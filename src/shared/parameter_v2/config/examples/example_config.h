#pragma once
#include <memory.h>
#include <stdlib.h>

#include "shared/parameter_v2/config/examples/parameter.h"

///////////////////////////////////////////////////////////////////////
//                 Generated C Config Structs                        //
///////////////////////////////////////////////////////////////////////
//
// We achieve immutability by setting IntegerParameter_t, BoolParameter_t etc
// to const. They can only be set during initialization. We also set the ptrs
// pointing to included configs as const.
//
// This allows us to expose the "internals" of the generated FooConfig struct,
// BarConfig struct, etc.. to let libraries know what parameters and configs
// are present inside.
//
typedef struct FooConfig_s
{
    IntegerParameter_t foo_int;
    BoolParameter_t foo_bool;
} FooConfig_t;

typedef struct BarConfig_s
{
    IntegerParameter_t bar_int;
    BoolParameter_t bar_bool;
} BarConfig_t;

typedef struct ExampleConfig_s
{
    // generated from an "include" statement in the yaml,
    // include:
    //      - "foo.yaml"
    //      - "bar.yaml"
    // It does NOT indicate hierarchy.
    const FooConfig_t* FooConfig;
    const BarConfig_t* BarConfig;

    // the parameters defined in example.yaml
    const BoolParameter_t example_bool_param;
    const UnsignedIntegerParameter_t example_uint_param;
    const IntegerParameter_t example_int_param;
    const FloatParameter_t example_float_param;
    const StringParameter_t example_string_param;
} ExampleConfig_t;

typedef struct ThunderbotsConfig
{
    const ExampleConfig_t* ExampleConfig;
} ThunderbotsConfig_t;

// this function should get called in the main.c
const ThunderbotsConfig_t* app_dynamic_parameters_create()
{
    // Allocate memory for all configs
    ThunderbotsConfig_t* thunderbots_config =
        (ThunderbotsConfig_t*)malloc(sizeof(ThunderbotsConfig_t));
    ExampleConfig_t* example_config = (ExampleConfig_t*)malloc(sizeof(ExampleConfig_t));
    FooConfig_t* foo_config         = (FooConfig_t*)malloc(sizeof(FooConfig_t));
    BarConfig_t* bar_config         = (BarConfig_t*)malloc(sizeof(BarConfig_t));

    // Create "initialization structs"
    ExampleConfig_t example_config_init = {
        .FooConfig            = foo_config,
        .BarConfig            = bar_config,
        .example_bool_param   = {.value = true},
        .example_uint_param   = {.value = 3},
        .example_int_param    = {.value = 3},
        .example_float_param  = {.value = 4.0f},
        .example_string_param = {.value = "Hello World"}};

    BarConfig_t bar_config_init = {
        .bar_int  = {.value = 3},
        .bar_bool = {.value = true},
    };

    FooConfig_t foo_config_init = {
        .foo_int  = {.value = 3},
        .foo_bool = {.value = true},
    };

    // Initialize Configs
    //
    // Memcpy allows us to NOT hit any undefined behaviour when initializing a const param
    // after malloc.
    //
    // We copy all the values from the stack-allocated struct into the
    // heap-malloc'd struct.
    //
    // https://stackoverflow.com/questions/9691404/how-to-initialize-const-in-a-struct-in-c-with-malloc
    memcpy(example_config, &example_config_init, sizeof(ExampleConfig_t));
    memcpy(bar_config, &bar_config_init, sizeof(BarConfig_t));
    memcpy(foo_config, &foo_config_init, sizeof(FooConfig_t));

    // Resolve Includes
    //
    // We "link" the configs together when requested w/ an include statement in the yaml
    //
    // include:
    //      - "foo.yaml"
    //      - "bar.yaml"
    thunderbots_config->ExampleConfig = example_config;
    example_config->FooConfig         = foo_config;
    example_config->BarConfig         = bar_config;

    return thunderbots_config;
}

// autogenerated "destructor"
void app_dynamic_parameters_destroy(ThunderbotsConfig_t* tbots_config)
{
    free((void*)tbots_config->ExampleConfig->FooConfig);
    free((void*)tbots_config->ExampleConfig->BarConfig);
    free((void*)tbots_config->ExampleConfig);
    free((void*)tbots_config);
}
