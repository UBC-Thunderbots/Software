from cpp_config import CppConfig
from cpp_parameter import CppParameter
from typing import List
from dynamic_parameter_schema import PARAMETER_KEY, INCLUDE_KEY
from util import to_upper_camel_case
import networkx as nx

#######################################################################
#                             CPP Writer                              #
#######################################################################

# The escape characters at the front change the color to red when
# printed in a terminal, and the escape characters at the end clears and resets
# back to the original color. More info can be found here:
# https://stackoverflow.com/questions/287871/print-in-terminal-with-colors
AUTOGEN_FAILURE_MSG = """\033[91m====================================================\033[0m
\033[91m                CFG AUTOGEN FAILURE
\u001b[34;1m Reason: {}
\033[91m====================================================\033[0m"""

# TODO: delete what's not necessary, change other paths
# the working directory is set to the current folder in CMakeLists
# PATH_TO_YAML = "./software/parameter/config/"
# PATH_TO_AUTOGEN_CFG = "./software/parameter/autogenerated/cfg/"
# PATH_TO_AUTOGEN_CPP = "./software/parameter/"
# PATH_TO_AUTOGEN_NODE = "./software/dynamic_reconfigure_manager/"
# DYNAMIC_PARMETERS_HEADER = "dynamic_parameters.h"
# DYNAMIC_PARMETERS_CPP = "dynamic_parameters.cpp"

AUTOGEN_WARNING = """
/**
 *  !! WARNING !!
 *
 *  THIS FILE IS AUTOGENERATED, ANY CHANGES MADE WILL BE LOST
 *
 *  !! WARNING !!
 */
"""

# TODO: figure out factory deps
CONFIG_H = (
    "{autogen_warning}"
    "#pragma once\n"
    "#include <boost/program_options.hpp>\n"
    "#include <iostream>\n"
    "#include <limits>\n"
    "\n"
    '#include "software/parameter/config.h"\n'
    '#include "software/parameter/enumerated_parameter.h"\n'
    '#include "software/parameter/numeric_parameter.h"\n'
    '#include "software/util/design_patterns/generic_factory.h"\n'
    "\n"
    "{include_headers}\n"
    "\n"
    "{forward_declarations}\n"
    "\n"
    "{contents}"
)

INCLUDE_HEADER = '#include "{header_file}"'

class CppWriter(object):
    @staticmethod
    def create_config_list_from_metadata( 
        top_level_config_name: str, config_metadata: dict
    ) -> List[CppConfig]:
        cpp_configs = []
        cpp_configs_dict = {}
        dependency_graph = nx.DiGraph()
        top_level_config = CppConfig(top_level_config_name, True)

        # first pass to construct all CppConfig objects
        for config, metadata in config_metadata.items():
            config_name = to_upper_camel_case(
                config.split(".")[0]
            )

            config = CppConfig(config_name)
            top_level_config.include_config(config)

            if PARAMETER_KEY in metadata:
                for parameter in metadata[PARAMETER_KEY]:
                    param_metadata = list(parameter.values())[0]
                    param_type = list(parameter.keys())[0]

                    cpp_param = CppParameter(param_type, param_metadata)
                    config.add_parameter(cpp_param)

            cpp_configs.append(config)  # TODO: just get list from dict?
            cpp_configs_dict[config_name] = config
            dependency_graph.add_node(config_name, config=config)

        # second pass to create dependency graph
        for config, metadata in config_metadata.items():
            config_name = to_upper_camel_case(config.split(".")[0])

            config = cpp_configs_dict[config_name]

            if INCLUDE_KEY in metadata:
                for included_yaml in metadata[INCLUDE_KEY]:
                    included_config_name = to_upper_camel_case(
                        included_yaml.split(".")[0]
                    )
                    config.include_config(cpp_configs_dict[included_config_name])
                    # add an edge from config node to included config node
                    dependency_graph.add_edge(config_name, included_config_name)

        # for each node, create a subgraph of relevant dependencies
        # Note: This can be optimized by doing traversal from each source, and creating subgraphs for
        # all its descendants during the same traversal
        for node in dependency_graph.nodes:
            # find the subgraph of the dependency graph relevant to the current node
            dependency_graph.nodes[node][
                "config"
            ].dependency_graph = dependency_graph.subgraph(
                nx.algorithms.dag.descendants(dependency_graph, node)
            )

        top_level_config.dependency_graph = dependency_graph
        cpp_configs = [
            dependency_graph.nodes[node]["config"]
            for node in list(reversed(list(nx.topological_sort(dependency_graph))))
        ]
        cpp_configs.append(top_level_config)

        # create graph of dependencies, with all sources as starting vertex
        return cpp_configs

    @staticmethod
    def write_config_metadata(
        output_file: str, include_headers: List[str], top_level_config_name: str, config_metadata: dict
    ):
        cpp_configs = CppWriter.create_config_list_from_metadata(
            top_level_config_name, config_metadata
        )

        # generate header file
        with open(f"{output_file}", "w") as header_file:
            contents = "\n".join([conf.definition for conf in cpp_configs])
            include_headers_formatted = "\n".join([INCLUDE_HEADER.format(header_file=header_file) for header_file in include_headers])
            forward_declarations = "\n".join(
                [conf.forward_declaration for conf in cpp_configs]
            )

            header_file.write(
                CONFIG_H.format(
                    autogen_warning=AUTOGEN_WARNING,
                    include_headers=include_headers_formatted,
                    forward_declarations=forward_declarations,
                    contents=contents,
                )
            )
