from cpp_config import CppConfig
from cpp_parameter import CppParameter
from typing import List
from dynamic_parameter_schema import PARAMETER_KEY, INCLUDE_KEY, CONSTANT_KEY
import networkx as nx

#######################################################################
#                             CPP Writer                              #
#######################################################################

# The escape characters at the front change the color to red when
# printed in a terminal, and the escape characters at the end clears and resets
# back to the original color. More info can be found here:
# https://stackoverflow.com/questions/287871/print-in-terminal-with-colors
AUTOGEN_FAILURE_MSG = """\033[91m====================================================\033[0m
\033[91m                CFG AUTOGEN FAILURE
\u001b[34;1m Reason: {}
\033[91m====================================================\033[0m"""

# TODO: delete what's not necessary, change other paths
# the working directory is set to the current folder in CMakeLists
PATH_TO_YAML = "./software/parameter/config/"
PATH_TO_AUTOGEN_CFG = "./software/parameter/autogenerated/cfg/"
PATH_TO_AUTOGEN_CPP = "./software/parameter/"
PATH_TO_AUTOGEN_NODE = "./software/dynamic_reconfigure_manager/"
DYNAMIC_PARMETERS_HEADER = "dynamic_parameters.h"
DYNAMIC_PARMETERS_CPP = "dynamic_parameters.cpp"

AUTOGEN_WARNING = """
/**
 *  !! WARNING !!
 *
 *  THIS FILE IS AUTOGENERATED, ANY CHANGES MADE WILL BE LOST
 *
 *  !! WARNING !!
 */
"""

# figure out factory deps
CONFIG_H = (
    "{autogen_warning}"
    "#pragma once\n"
    "#include <boost/program_options.hpp>\n"
    "#include <iostream>\n"
    "#include <limits>\n"
    "\n"
    '#include "shared/parameter_v2/config.h"\n'
    '#include "shared/parameter_v2/enumerated_parameter.h"\n'
    '#include "shared/parameter_v2/numeric_parameter.h"\n'
    '#include "software/util/design_patterns/generic_factory.h"\n'
    "\n"
    "{forward_declarations}\n"
    "\n"
    "{contents}"
)

# TODO: run generated file through formatter after


class CppWriter(object):
    @staticmethod
    def create_config_list_from_metadata(  # TODO: add type to args
        top_level_config_name, config_metadata
    ) -> List[CppConfig]:
        cpp_configs = []
        cpp_configs_dict = {}
        dependency_graph = nx.DiGraph()

        # first pass to construct all CppConfig objects
        for config, metadata in config_metadata.items():
            config_name = CppWriter.to_camel_case(
                config.split(".")[0]
            )  # TODO: just use Cwriter to_camel_case for all usages of the function

            config = CppConfig(config_name)

            if PARAMETER_KEY in metadata:
                for parameter in metadata[PARAMETER_KEY]:
                    param_metadata = list(parameter.values())[0]
                    param_type = list(parameter.keys())[0]

                    cpp_param = CppParameter(param_type, param_metadata)
                    config.add_parameter(cpp_param)

            cpp_configs.append(config)  # TODO: just get list from dict?
            cpp_configs_dict[config_name] = config
            dependency_graph.add_node(config_name, config=config)

        # second pass to create dependency graph
        for config, metadata in config_metadata.items():
            config_name = CppWriter.to_camel_case(config.split(".")[0])

            config = cpp_configs_dict[config_name]

            if INCLUDE_KEY in metadata:
                for included_yaml in metadata[INCLUDE_KEY]:
                    included_config_name = CppWriter.to_camel_case(
                        included_yaml.split(".")[0]
                    )
                    config.include_config(cpp_configs_dict[included_config_name])
                    # add an edge from config node to included config node
                    dependency_graph.add_edge(config_name, included_config_name)

        print(dependency_graph.edges)
        print(dependency_graph.nodes)

        # for each node, create a subgraph of relevant dependencies
        # Note: This can be optimized by doing traversal from each source, and creating subgraphs for
        # all its descendants during the same traversal
        for node in dependency_graph.nodes:
            # find the subgraph of the dependency graph relevant to the current node
            dependency_graph.nodes[node][
                "config"
            ].dependency_graph = dependency_graph.subgraph(
                nx.algorithms.dag.descendants(dependency_graph, node)
            )

        for node in dependency_graph.nodes:
            # all nodes have dependency graph set, init the rest of config properties
            # TODO: maybe do this in reverse topo order to avoid doing post_init
            dependency_graph.nodes[node]["config"].post_dependency_graph_init()

        # create cpp config objects
        # create a dict from

        # create graph of dependencies, with all sources as starting vertex
        return cpp_configs

    @staticmethod
    def create_top_level_config(top_level_config_name):
        return 0

    @staticmethod
    def write_config_metadata(
        output_file: str, top_level_config_name: str, config_metadata: dict
    ):
        print("========================================")
        cpp_configs = CppWriter.create_config_list_from_metadata(
            top_level_config_name, config_metadata
        )

        # generate header file
        with open(f"{output_file}", "w") as header_file:
            contents = "\n".join([conf.definition for conf in cpp_configs])
            forward_declarations = "\n".join(
                [conf.forward_declaration for conf in cpp_configs]
            )

            header_file.write(
                CONFIG_H.format(
                    autogen_warning=AUTOGEN_WARNING,
                    forward_declarations=forward_declarations,
                    contents=contents,
                )
            )

    @staticmethod
    def to_camel_case(snake_str):
        return "".join(x.title() for x in snake_str.split("_"))
