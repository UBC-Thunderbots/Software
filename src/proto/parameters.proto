syntax = "proto2";

package TbotsProto;

import "proto/play.proto";
import "google/protobuf/descriptor.proto";

message ParameterRangeOptions
{
    optional double min_double_value = 1;
    optional double max_double_value = 2;
    optional int64 min_int_value     = 3;
    optional int64 max_int_value     = 4;
}

extend google.protobuf.FieldOptions
{
    // range is taken in python
    optional ParameterRangeOptions bounds = 5000;
}

message ThunderbotsConfig
{
    required AiConfig ai_config                      = 1;
    required SensorFusionConfig sensor_fusion_config = 2;
}


message AiConfig
{
    reserved 4, 8;

    required AiControlConfig ai_control_config                              = 1;
    required DribbleConfig dribble_config                                   = 2;
    required AttackerTacticConfig attacker_tactic_config                    = 3;
    required PassingConfig passing_config                                   = 5;
    required GoalieTacticConfig goalie_tactic_config                        = 6;
    required EnemyCapabilityConfig enemy_capability_config                  = 7;
    required RobotCapabilitiesConfig robot_capabilities_config              = 9;
    required DefensePlayConfig defense_play_config                          = 11;
    required RobotNavigationObstacleConfig robot_navigation_obstacle_config = 12;
    required AiParameterConfig ai_parameter_config                          = 13;
    required ShotConfig shot_config                                         = 14;
    required ReceiverTacticConfig receiver_tactic_config                    = 15;
}

message AiControlConfig
{
    // Whether we should run or stop ai
    required bool run_ai = 1 [default = true];

    // Override the existing play with the Play enum provided
    required PlayName override_ai_play = 2 [default = UseAiSelection];
}

message AiParameterConfig
{
    // threshold to decide if ball hasn't been kicked
    required double ball_is_kicked_m_per_s_threshold = 1
        [default = 0.3, (bounds).min_double_value = 0.0, (bounds).max_double_value = 5.0];

    // Multiplier to decrease the tactic assignment cost for robots previously
    // assigned to the tactic (makes tactic assignment "sticky")
    required double repeat_tactic_assignment_multiplier = 2
        [default = 0.5, (bounds).min_double_value = 0.0, (bounds).max_double_value = 1.0];
}

message AttackerTacticConfig
{
    // The radius of the circle around a friendly robot around which
    // we think an enemy is about to steal the ball
    required double enemy_about_to_steal_ball_radius = 1
        [default = 0.4, (bounds).min_double_value = 0.0, (bounds).max_double_value = 4.0];

    // The minimum open angle to the goal that we require before taking a shot
    required double min_open_angle_for_shot_deg = 2 [
        default                   = 6.0,
        (bounds).min_double_value = 0.1,
        (bounds).max_double_value = 90.0
    ];

    /*****  Q-learning hyperparameters *****/
    
    // The learning rate determines the extent to which new information overrides old information.
    // A higher learning rate means more emphasis on recent information.
    required double learning_rate = 3
        [default = 0.2, (bounds).min_double_value = 0.0, (bounds).max_double_value = 1.0];

    // The discount factor determines the importance of future rewards.
    // A factor of 0 makes the agent consider only immediate rewards, ignoring future rewards 
    // completely. This makes the agent myopic, focusing solely on short-term gains.
    // A factor closer to 1 makes the agent consider future rewards more significantly, 
    // encouraging it to evaluate long-term benefits.
    required double discount_factor = 4
        [default = 0.8, (bounds).min_double_value = 0.0, (bounds).max_double_value = 1.0];

    // Controls the epsilon parameter if using an epsilon-greedy selection strategy.
    // The epsilon determines the exploration-exploitation balance; higher epsilons lead to
    // more exploration of the action space, while lower epsilons favor exploitation 
    // of the best-known actions.
    required double action_selection_epsilon = 5
        [default = 0.1, (bounds).min_double_value = 0.0, (bounds).max_double_value = 10.0];

    // Controls the temperature parameter if using a softmax action selection strategy.
    // Temperature determines the exploration-exploitation balance; higher temperatures 
    // lead to more exploration of the action space, while lower temperatures favor exploitation 
    // of the best-known actions.
    required double action_selection_temperature = 6
        [default = 0.3, (bounds).min_double_value = 0.0, (bounds).max_double_value = 10.0];
}

message ReceiverTacticConfig
{
    // Whether one touch kicks should be disabled or not
    required bool disable_one_touch_kick = 1 [default = false];

    // The minimum open angle to the goal that we require before taking a one touch kick
    required double min_open_angle_for_one_touch_deg = 2 [
        default                   = 6.0,
        (bounds).min_double_value = 0.1,
        (bounds).max_double_value = 90.0
    ];

    // TODO (#2570): try to make it as big as possible when tuning
    // The maximum deflection angle that we will attempt a one-touch kick towards the
    // enemy goal with
    required double max_deflection_for_one_touch_deg = 3 [
        default                   = 45.0,
        (bounds).min_double_value = 10.0,
        (bounds).max_double_value = 90.0
    ];
}

message PassingConfig
{
    // Note that the order the fields are defined here is the order that
    // they are displayed in Thunderscope's Parameters widget, and the order
    // is independent of the field's numbering.

    /*****  Pass generation parameters *****/
    // The number of passes to sample per robot.
    required uint32 pass_gen_num_samples_per_robot = 17
        [default = 5, (bounds).min_int_value = 1, (bounds).max_int_value = 100];
    // The standard deviation (in meters) of the normal sampling distribution
    // used to generate passes around robots.
    required double pass_gen_rand_sample_std_dev_meters = 18 [
        default                   = 0.2,
        (bounds).min_double_value = 0.01,
        (bounds).max_double_value = 3.0
    ];
    // The minimum pass speed (in m/s)
    required double min_pass_speed_m_per_s = 6
        [default = 2.0, (bounds).min_double_value = 0.0, (bounds).max_double_value = 5.0];
    // The maximum pass speed (in m/s)
    required double max_pass_speed_m_per_s = 7 [
        default                   = 6.0,
        (bounds).min_double_value = 0.0,
        (bounds).max_double_value = 10.0
    ];
    // The max speed at which a pass should be received
    required double max_receive_speed_m_per_s = 11
        [default = 2.0, (bounds).min_double_value = 1.0, (bounds).max_double_value = 4.0];
    // The number of steps of gradient descent to perform in each iteration
    required int32 number_of_gradient_descent_steps_per_iter = 9
        [default = 2, (bounds).min_int_value = 0, (bounds).max_int_value = 100];

    /*****  Cost function parameters *****/
    // The offset from the sides of the field to place the rectangular
    // sigmoid we use to determine what areas to pass to
    required double static_field_position_quality_x_offset = 1
        [default = 0.3, (bounds).min_double_value = 0.0, (bounds).max_double_value = 1.0];
    // The offset from the sides of the field to place the rectangular
    // sigmoid we use to determine what areas to pass to
    required double static_field_position_quality_y_offset = 2
        [default = 0.3, (bounds).min_double_value = 0.0, (bounds).max_double_value = 1.0];
    // The weight that being close to the goal will have on the static
    // position quality. Lower, more negative weights result in the distance
    // to the goal having less of an effect.
    required double static_field_position_quality_friendly_goal_distance_weight = 3
        [default = 0.3, (bounds).min_double_value = 0.0, (bounds).max_double_value = 1.0];
    // This controls how heavily we weigh an enemy robot being near the pass
    // receiver when calculating enemy risk to a pass
    required double enemy_proximity_importance = 4 [
        default                   = 0.5,
        (bounds).min_double_value = 0.0,
        (bounds).max_double_value = 10.0
    ];  // TODO (NIMA): ignored
    // The maximum angle that we have to rotate after receiving a pass to
    // shoot that we think would likely result in a goal. Note that we may
    // try to take shots that require us to rotate more then this, it's more
    // of a soft limit.
    required double ideal_max_rotation_to_shoot_degrees = 5 [
        default                   = 60.0,
        (bounds).min_double_value = 0.0,
        (bounds).max_double_value = 180.0
    ];  // TODO (NIMA): ignored
    // How long we think the enemy will take to recognize we're passing and start
    // moving to intercept
    required double enemy_reaction_time = 8 [
        default                   = 0.2,
        (bounds).min_double_value = 0.0,
        (bounds).max_double_value = 3.0
    ];  // TODO (NIMA): ignored
    // The distance in meters along the x-axis from the passer that we prefer the receiver
    // to be when receiving a pass. Note that this is a soft limit and the receiver may be
    // further back.
    required double backwards_pass_distance_meters = 13 [
        default                   = -1.0,
        (bounds).min_double_value = -10.0,
        (bounds).max_double_value = 5.0
    ];
    // The max distance in meters that the receiver can be from the passer when receiving
    // a pass.
    required double receiver_ideal_max_distance_meters = 14 [
        default                   = 7.0,
        (bounds).min_double_value = 0.1,
        (bounds).max_double_value = 20.0
    ];
    // The min distance in meters that the receiver can be from the passer when receiving
    // a pass.
    required double receiver_ideal_min_distance_meters = 15 [
        default                   = 2.0,
        (bounds).min_double_value = 0.1,
        (bounds).max_double_value = 20.0
    ];
    // The min score that ratePassShootScore return.
    required double min_pass_shoot_score = 16
        [default = 0.5, (bounds).min_double_value = 0.0, (bounds).max_double_value = 1.0];

    /*****  PassSkill parameters *****/
    // The absolute minimum pass quality we're willing to attempt
    required double abs_min_pass_score = 20 [
        default                   = 0.05,
        (bounds).min_double_value = 0.0,
        (bounds).max_double_value = 1.0
    ];
    // When we're choosing a pass, we start by looking for a pass with a perfect score
    // of 1, and then over time lower the score we're will to accept. This parameter
    // how fast we ramp down to abs_min_pass_score. This is in seconds.
    required double pass_score_ramp_down_duration = 21
        [default = 2.0, (bounds).min_double_value = 0.0, (bounds).max_double_value = 5.0];
    // Width of the pass lane area that the ball must be inside of during the pass
    required double pass_lane_width_meters = 22
        [default = 0.5, (bounds).min_double_value = 0.0, (bounds).max_double_value = 2.0];
    /*****  Visualization parameters *****/
    // Cost function visualization parameters
    required CostVisualizationConfig cost_vis_config = 10;
}

message GoalieTacticConfig
{
    reserved 1;

    // At what speed of the ball should the goalie panic and stop the ball
    required double ball_speed_panic = 2
        [default = 0.2, (bounds).min_double_value = 0.0, (bounds).max_double_value = 6.0];
    // The radius to wedge the robot into the cone
    required double block_cone_radius = 3
        [default = 0.3, (bounds).min_double_value = 0.0, (bounds).max_double_value = 1.0];
    // How much to deflate the defense area by, larger value means closer to the net
    required double defense_area_deflation = 4
        [default = 0.2, (bounds).min_double_value = 0.1, (bounds).max_double_value = 0.5];
    // Depth goalie should be at for plays close to the defense area (potential lateral
    // play, rebounds)
    required double conservative_depth_meters = 5
        [default = 0.3, (bounds).min_double_value = 0.0, (bounds).max_double_value = 2.0];
    // Depth goalie should be at to aggressively narrow the angle the ball has to the
    // goal as it enters the friendly half
    required double aggressive_depth_meters = 6
        [default = 0.7, (bounds).min_double_value = 0.0, (bounds).max_double_value = 2.0];
    // Distance in meters to inset the target area for finding chip targets
    required double chip_target_area_inset_meters = 7
        [default = 0.3, (bounds).min_double_value = 0.0, (bounds).max_double_value = 2.0];
    // Minimum distance in meters that a chip target must be away from the front
    // defense area crease
    required double min_chip_distance_from_crease_meters = 8
        [default = 2, (bounds).min_double_value = 0.0, (bounds).max_double_value = 10.0];
    // Distance threshold multiplier used for calculating whether or not an enemy robot
    // is a safe distance away
    required double safe_distance_multiplier = 9
        [default = 2, (bounds).min_double_value = 0.0, (bounds).max_double_value = 10.0];
}

message ShotConfig
{
    // Number of shot origin points to sample when finding the best shot to take
    required int32 num_shot_origin_points_to_sample = 1
        [default = 8, (bounds).min_int_value = 0, (bounds).max_int_value = 16];
}

message DribbleConfig
{
    // If ball and front of robot are separated by this amount, then we've lost
    // control over the ball (in m)
    required double lose_ball_control_threshold = 1 [
        default                   = 0.04,
        (bounds).min_double_value = 0.0,
        (bounds).max_double_value = 1.0
    ];

    // Threshold to determine if the ball is at the destination determined
    // experimentally (in m)
    required double ball_close_to_dest_threshold = 2
        [default = 0.1, (bounds).min_double_value = 0.0, (bounds).max_double_value = 1.0];

    // Threshold to determine if the robot has the expected orientation when
    // completing the dribble (in degrees)
    required double final_destination_close_threshold = 3 [
        default                   = 3.0,
        (bounds).min_double_value = 0.0,
        (bounds).max_double_value = 10.0
    ];

    // Maximum distance to continuously dribble the ball,
    // slightly conservative to not break the 1 meter rule (in m)
    required double max_continuous_dribbling_distance = 4 [
        default                   = 0.78,
        (bounds).min_double_value = 0.0,
        (bounds).max_double_value = 2.0
    ];

    // Robot speed at which the robot is done dribbling (in m/s)
    required double robot_dribbling_done_speed = 5
        [default = 1.0, (bounds).min_double_value = 0.0, (bounds).max_double_value = 1.0];
}

message EnemyCapabilityConfig
{
    // This value should be set based on whether or not the team we are playing against
    // can pass the ball. This will affect how we defend against the team.
    required bool enemy_team_can_pass = 1 [default = true];
}

message RobotCapabilitiesConfig
{
    // Comma-separated list of numbers of robots with broken dribblers
    required string broken_dribblers = 1;
    // Comma-separated list of numbers of robots with broken chippers
    required string broken_chippers = 2;
    // Comma-separated list of numbers of robots with broken kickers
    required string broken_kickers = 3;
}

message SensorFusionConfig
{
    // Ignores frames if our goalie appears in the opponent defense area
    required bool vision_flipping_filter_enabled = 1 [default = true];

    // Whether or not to ignore invalid camera data. If this value is true, any ball or
    // robot detections that are not within the min and max valid x coordinates will be
    // ignored. If this value is false, all data is collected as normal and not ignored.
    required bool ignore_invalid_camera_data = 2 [default = false];

    // When ignoreInvalidCameraData is true, any robot or ball detection with an
    // x-coordinate less than this value is ignored.
    required double min_valid_x = 3 [
        default                   = -10.0,
        (bounds).min_double_value = -10.0,
        (bounds).max_double_value = 10.0
    ];

    // When ignoreInvalidCameraData is true, any robot or ball detection with an
    // x-coordinate greater than this value is ignored.
    required double max_valid_x = 4 [
        default                   = -10.0,
        (bounds).min_double_value = -10.0,
        (bounds).max_double_value = 10.0
    ];

    // The id of the friendly goalie
    required int32 friendly_goalie_id = 5
        [default = 0, (bounds).min_int_value = 0, (bounds).max_int_value = 16];

    // The id of the enemy goalie
    required int32 enemy_goalie_id = 6
        [default = 0, (bounds).min_int_value = 0, (bounds).max_int_value = 16];

    // Yellow if selected, Blue if unselected
    required bool friendly_color_yellow = 9 [default = true];

    // Overrides the friendly goalie id provided by the game controller,
    // with FriendlyGoalieId parameter
    required bool override_game_controller_friendly_goalie_id = 10 [default = true];

    // Overrides the enemy goalie id provided by the game controller,
    // with EnemyGoalieId parameter
    required bool override_game_controller_enemy_goalie_id = 11 [default = true];

    // Number of dropped detections before we consider the ball not to be in the dribbler
    required int32 num_dropped_detections_before_ball_not_in_dribbler = 12
        [default = 3, (bounds).min_int_value = 0, (bounds).max_int_value = 1000];

    // Possession tracker for determining which team has possession of the ball
    required PossessionTrackerConfig possession_tracker_config = 13;
}

message DefensePlayConfig
{
    message DefenderAssignmentConfig
    {
        // The minimum distance in meters between two threats for them to be considered
        // non-similar
        required double min_distance_between_threats_meters = 1 [
            default                   = 0.25,
            (bounds).min_double_value = 0.0,
            (bounds).max_double_value = 10.0
        ];

        // The minimum difference between two threats in angle to the primary threat for
        // them to be considered non-similar
        required double min_angle_between_threats_degrees = 2 [
            default                   = 10.0,
            (bounds).min_double_value = 0.0,
            (bounds).max_double_value = 360.0
        ];

        // Multiplier to ensure that goal lanes are scored higher (in threat rating)
        // than passing lanes
        required double goal_lane_threat_multiplier = 3 [
            default                   = 3.0,
            (bounds).min_double_value = 0.0,
            (bounds).max_double_value = 10.0
        ];

        // Max percent difference between two goal lanes' angles to goal for them to be
        // considered a dense lane cluster
        required double goal_lane_density_threshold = 4 [
            default                   = 0.4,
            (bounds).min_double_value = 0.0,
            (bounds).max_double_value = 100.0
        ];

        // Bonus added to coverage rating if the goal lane is not part of a dense cluster
        required double goal_lane_nondense_bonus = 5 [
            default                   = 0.5,
            (bounds).min_double_value = 0.0,
            (bounds).max_double_value = 10.0
        ];
    }

    // The distance at which a threat is considered "immediate" if there is only 1
    // "immediate" threat the defense play will swarm that robot with shadowers
    required double immediate_threat_distance = 1
        [default = 6.0, (bounds).min_double_value = 0.0, (bounds).max_double_value = 9.5];

    // The DefenderAssignmentConfig for tuning defender assignments
    required DefenderAssignmentConfig defender_assignment_config = 2;
}

message RobotNavigationObstacleConfig
{
    required double robot_obstacle_inflation_factor = 1 [
        default                   = 1.2,
        (bounds).min_double_value = 0.0,
        (bounds).max_double_value = 10.0
    ];

    // The additional inflation amount (in meters) for the enemy defense area
    required double enemy_defense_area_additional_inflation_meters = 2
        [default = 0.3, (bounds).min_double_value = 0.0, (bounds).max_double_value = 1.0];

    // The minimum velocity of an enemy robot for it to be considered
    // as a dynamic obstacle. Below this speed, the robot is considered
    // to be stationary.
    required double dynamic_enemy_robot_obstacle_min_speed_mps = 3
        [default = 0.5, (bounds).min_double_value = 0.0, (bounds).max_double_value = 3.0];

    // The maximum time into the future that we will predict the enemy
    // robot's position for obstacle avoidance
    required double dynamic_enemy_robot_obstacle_horizon_sec = 4
        [default = 0.4, (bounds).min_double_value = 0.0, (bounds).max_double_value = 2.0];
}

message CostVisualizationConfig
{
    // Whether we should generate sample passes for the cost visualization
    required bool generate_sample_passes = 1 [default = false];
    required int32 num_cols              = 2
        [default = 45, (bounds).min_int_value = 1, (bounds).max_int_value = 100];
    // cost functions
    required bool static_position_quality  = 3 [default = false];
    required bool pass_friendly_capability = 4 [default = false];
    required bool pass_enemy_risk          = 5 [default = false];
    required bool pass_shoot_score         = 6 [default = false];
    required bool passer_position_score    = 7 [default = false];
    required bool receiver_position_score  = 8 [default = false];
}

message PossessionTrackerConfig
{
    // Max distance in meters between robot and ball for robot
    // to be considered near the ball
    required double distance_near_tolerance_meters = 1
        [default = 0.1, (bounds).min_double_value = 0.0, (bounds).max_double_value = 5.0];

    // Min distance in meters between robot and ball for robot
    // to be considered far away from the ball
    required double distance_far_tolerance_meters = 2 [
        default                   = 0.5,
        (bounds).min_double_value = 0.0,
        (bounds).max_double_value = 10.0
    ];

    // Min time in seconds that robot must stay close to ball for
    // it to be considered near
    required double time_near_threshold_s = 3
        [default = 0.1, (bounds).min_double_value = 0.0, (bounds).max_double_value = 3.0];

    // Min time in seconds that robot must stay away from ball for
    // it to be considered far away
    required double time_far_threshold_s = 4 [
        default                   = 1.5,
        (bounds).min_double_value = 0.0,
        (bounds).max_double_value = 10.0
    ];
}
