syntax = "proto2";

package TbotsProto;

import "proto/geometry.proto";
import "proto/primitive.proto";
import "proto/world.proto";

message AssignedTacticPlayControlParams
{
    map<uint32, Tactic> assigned_tactics = 1;
}

message Tactic
{
    oneof tactic
    {
        AttackerTactic attacker                             = 1;
        ChipTactic chip                                     = 2;
        CreaseDefenderTactic crease_defender                = 3;
        GoalieTactic goalie                                 = 6;
        MoveGoalieToGoalLineTactic move_goalie_to_goal_line = 8;
        MoveTactic move                                     = 9;
        PenaltyKickTactic penalty_kick                      = 10;
        ReceiverTactic receiver                             = 12;
        ShadowEnemyTactic shadow_enemy                      = 13;
        StopTactic stop                                     = 14;
        PassDefenderTactic pass_defender                    = 15;
        ShootSkillTactic shoot_skill                        = 16;
    }
    reserved 4, 5, 11;
}

message AttackerTactic
{
    // The best pass so far
    optional Pass best_pass_so_far = 1;
    // whether we have committed to the pass and will be taking it
    required bool pass_committed = 2;
    // The point the robot will chip towards if it is unable to shoot and is in danger
    // of losing the ball to an enemy
    optional Point chip_target = 3;
}

message ChipTactic
{
    // The location where the chip will be taken from
    required Point chip_origin = 1;
    // The direction the Robot will chip in
    required Angle chip_direction = 2;
    // The distance the robot will chip to
    required double chip_distance_meters = 3;
}

enum CreaseDefenderAlignment
{
    LEFT   = 0;
    RIGHT  = 1;
    CENTRE = 2;
}

message CreaseDefenderTactic
{
    // The origin point of the enemy threat
    required Point enemy_threat_origin = 1;
    // The crease defender alignment with respect to the enemy threat
    required CreaseDefenderAlignment crease_defender_alignment = 2;
    // The maximum allowed speed mode
    required MaxAllowedSpeedMode max_allowed_speed_mode = 3;
}

message GoalieTactic
{
    // The maximum allowed speed mode
    required MaxAllowedSpeedMode max_allowed_speed_mode = 1;
}

message MoveGoalieToGoalLineTactic {}

message MoveTactic
{
    // The point the robot is trying to move to
    required Point destination = 1;
    // The orientation the robot should have when it arrives at its destination
    required Angle final_orientation = 2;
    // The speed the robot should have when it arrives at its destination
    required double final_speed = 3;
    // How to run the dribbler
    required DribblerMode dribbler_mode = 4;
    // How to navigate around the ball
    required BallCollisionType ball_collision_type = 5;
    // The command to autochip or autokick
    required AutoChipOrKick auto_chip_or_kick = 6;
    // The maximum allowed speed mode
    required MaxAllowedSpeedMode max_allowed_speed_mode = 7;
    // The target spin while moving in revolutions per second
    required double target_spin_rev_per_s = 8;
    // The obstacle avoidance mode to use while moving
    required ObstacleAvoidanceMode obstacle_avoidance_mode = 9;
}

message PassDefenderTactic
{
    // The location on the field to block enemy passes from
    required Point position_to_block_from = 1;
}

message PenaltyKickTactic {}

message ReceiverTactic
{
    // The pass to receive
    optional Pass pass = 1;
    // If set to true, we will only receive and dribble
    required bool disable_one_touch_shot = 2;
}

message ShadowEnemyTactic
{
    // The Enemy Threat indicating which enemy to shadow
    optional EnemyThreat enemy_threat = 1;

    // How far from the enemy the robot will position itself to shadow. If the enemy
    // threat has the ball, it will position itself to block the shot on goal.
    // Otherwise it will try to block the pass to the enemy threat.
    required double shadow_distance = 2;
}

message StopTactic {}

message ShootSkillTactic {}
