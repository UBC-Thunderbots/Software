syntax = "proto2";

package TbotsProto;

import "proto/geometry.proto";
import "proto/primitive.proto";
import "proto/world.proto";

message AssignedTacticPlayControlParams
{
    map<uint32, Tactic> assigned_tactics = 1;
}

message Tactic
{
    oneof tactic
    {
        AttackerTactic attacker                             = 1;
        CreaseDefenderTactic crease_defender                = 3;
        GoalieTactic goalie                                 = 6;
        MoveGoalieToGoalLineTactic move_goalie_to_goal_line = 8;
        MoveTactic move                                     = 9;
        PenaltyKickTactic penalty_kick                      = 10;
        ReceiverTactic receiver                             = 12;
        ShadowEnemyTactic shadow_enemy                      = 13;
        StopTactic stop                                     = 14;
        PassDefenderTactic pass_defender                    = 15;
        KickSkillTactic kick_skill                          = 16;
        PivotKickSkillTactic pivot_kick_skill               = 17;
        ShootSkillTactic shoot_skill                        = 18;
        DribbleSkillTactic dribble_skill                    = 19;
    }
    reserved 2, 4, 5, 7, 11;
}

message AttackerTactic {}

enum CreaseDefenderAlignment
{
    LEFT   = 0;
    RIGHT  = 1;
    CENTRE = 2;
}

enum BallStealMode
{
    // The robot avoids stealing ball/getting possession
    IGNORE = 0;
    // The robot can steal the ball/try to get possession of the ball
    STEAL = 1;
}

message CreaseDefenderTactic
{
    // The origin point of the enemy threat
    required Point enemy_threat_origin = 1;
    // The crease defender alignment with respect to the enemy threat
    required CreaseDefenderAlignment crease_defender_alignment = 2;
    // The maximum allowed speed mode
    required MaxAllowedSpeedMode max_allowed_speed_mode = 3;
    // The crease defender's aggressiveness towards the ball
    required BallStealMode ball_steal_mode = 4;
}

message GoalieTactic
{
    // The maximum allowed speed mode
    required MaxAllowedSpeedMode max_allowed_speed_mode = 1;
}

message MoveGoalieToGoalLineTactic {}

message MoveTactic
{
    // The point the robot is trying to move to
    required Point destination = 1;
    // The orientation the robot should have when it arrives at its destination
    required Angle final_orientation = 2;
    // The speed the robot should have when it arrives at its destination
    required double final_speed = 3;
    // How to run the dribbler
    required DribblerMode dribbler_mode = 4;
    // How to navigate around the ball
    required BallCollisionType ball_collision_type = 5;
    // The command to autochip or autokick
    required AutoChipOrKick auto_chip_or_kick = 6;
    // The maximum allowed speed mode
    required MaxAllowedSpeedMode max_allowed_speed_mode = 7;
    // The target spin while moving in revolutions per second
    required double target_spin_rev_per_s = 8;
    // The obstacle avoidance mode to use while moving
    required ObstacleAvoidanceMode obstacle_avoidance_mode = 9;
}

message PassDefenderTactic
{
    // The location on the field to block enemy passes from
    required Point position_to_block_from = 1;
    // The pass defender's aggressiveness towards the ball
    required BallStealMode ball_steal_mode = 2;
}

message PenaltyKickTactic {}

message ReceiverTactic
{
    // The point at which to receive the pass
    optional Point receiving_position = 1;
    // If set to false, we will only receive and dribble
    required bool enable_one_touch_shot = 2;
}

message ShadowEnemyTactic
{
    // The Enemy Threat indicating which enemy to shadow
    optional EnemyThreat enemy_threat = 1;

    // How far from the enemy the robot will position itself to shadow. If the enemy
    // threat has the ball, it will position itself to block the shot on goal.
    // Otherwise it will try to block the pass to the enemy threat.
    required double shadow_distance = 2;
}

message StopTactic {}

enum ExcessiveDribblingMode
{
    // Allow excessive dribbling (i.e. more than 1 meter at a time)
    ALLOWED = 0;

    // Lose ball control if we excessively dribble
    LOSE_BALL = 1;

    // Terminate the DribbleSkill if we excessively dribble,
    // regardless of whether we make it to the final dribble destination
    TERMINATE = 2;
}

message ShootSkillTactic {}

message DribbleSkillTactic {
    required Point dribble_destination = 1;
    optional Angle final_orientation = 2;
    required ExcessiveDribblingMode excessive_dribbling_allowed = 3;
    optional MaxAllowedSpeedMode max_speed_dribble = 4;
    optional MaxAllowedSpeedMode max_speed_get_possession = 5;
}

message PivotKickSkillTactic
{
    // The location where the kick will be taken from
    required Point kick_origin = 1;
    // The direction the Robot will kick in
    required Angle kick_direction = 2;
    // How the robot will chip or kick the ball
    required AutoChipOrKick auto_chip_or_kick = 3;
}

message KickSkillTactic
{
    // The location where the kick will be taken from
    required Point kick_origin = 1;
    // The direction the Robot will kick in
    required Angle kick_direction = 2;
    // How fast the Robot will kick the ball in meters per second
    required double kick_speed_meters_per_second = 3;
}
