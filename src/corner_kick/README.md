<p align="center">
  <img src="./src/assets/logo.svg" width="64px">
  <br>
  <h1 align="center">Corner Kick</h1>
</p>

Corner Kick is a web app that allows for the visualization of UBC Thunderbots' AI.

![application screenshot](screenshot.png)

**Table of content**

- [How to use](#how-to-use)
- [Contribute](#contribute)
  - [Running the dev server](#running-the-dev-server)
- [Project Structure](#project-structure)
- [Design notes](#design-notes)
  - [Approach to the application UI layout](#approach-to-the-application-ui-layout)
  - [Approach to the application state](#approach-to-the-application-state)

## How to use

You can start the visualizer by running:

```
roslaunch corner_kick corner_kick.launch
```

## Contribute

### Running the dev server

You can test your code by running:

```
roslaunch rosbridge_server rosbridge_websocket.launch
```

and in another window:

```
yarn
yarn start
```

A window should open with the application in development mode.

## Project Structure

The project is defined as follow:

-   `config` - contains webpack (build tool) configuration files
-   `launch` - contains roslaunch file
-   `src`
    -   `assets` - contains image assets
    -   `components` - contains repeatable UI components
    -   `containers` - contains high-level UI components (logger, visualizer, etc.)
    -   `constants` - contains fixed values used throughout the application
    -   `store` - contains logic for the application Redux state
    -   `types` - contains all Typescript types
    -   `utils` - contains misc code
-   `.prettierrc` - configuration for autoformating tool
-   `CMakeLists.txt` - cmake build script
-   `common.d.ts` - definition file for file assets
-   `package.json` - specifies dependencies, dev and build scripts.
-   `package.xml` - specifies ros dependencies
-   `tsconfig.json` - configuration file for typescript compiler
-   `tslint.json` - configuration for typescript linter
-   `yarn.lock` - autogenerated lock file for javascript dependencies

## Design notes

### Approach to the application UI layout

The visualizer will consist of multiple pages, each of which serve a single purpose. Each page will
be divided into sections as follow:

-   **Main:** Contains the primary focus of the page
-   **Sidebar title:** Contains the page title and additional options specific to the page
-   **Sidebar:** Contains additional controls or information relevant to the current page
-   **Sidebar control:** Contains navigation controls to switch between pages
-   **Console:** Contains views visible across the application
-   **Footer:** Contains simple breadcrumbs of information relevant to the application as a whole or to the current page

The application's primary layout is defined in [index.html](src/index.html) and styling for the layout is
defined in [style.css](src/style.css). The theme for the application is defined in [Theme.tsx](src/containers/mainUI/Theme.tsx)

Access to those section in the React application is done via [React Portals](https://reactjs.org/docs/portals.html).
Portals are used to ensure the application layout is enforced throughout all the pages while offering an
easy way to access them.

In essence then, the sections of the application are boxes where the React application can insert React components into.
This allows us to insert and swap UI elements in the application without worrying about the global layout.

### Approach to the application state

We are using [Redux](https://redux.js.org/) to manage the application state. Simply put, in Redux, the state is an
immutable object. It can only be replaced by a new version of itself when some sort of action occurs in the application.
This action is captured by a reducer function, which accepts the current state and the action, and returns a new state,
with potentially new values based on the action received.

React, then, becomes an extension of the global Redux state and does not contain state of its own. When the global state
changes, the React UI will automagically change to adapt to the new state.

Reducer functions do not permit for any side-effects to ensure a deterministic behaviour. For a state and action, the same new
state should be returned by the reducer funtion. This, however, does not permit for more complex logic, such as communicating
with ROS, to occur. To allow for this, we introduce sagas, which can intercept and act on Redux action. They can conduct some
business logic work, and reflect the result of this work in the state by emmiting a Redux action when needed.
