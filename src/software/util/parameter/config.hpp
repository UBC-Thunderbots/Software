#pragma once

#include <string>
#include <variant>
#include <vector>

#include "software/util/parameter/parameter.h"

class Config;
class MutableConfig;

// A ParameterVariant is a variant of shared_ptrs of parameters of int/bool/double/string
// or to a Config object which is a collection of parameters or configs iteslf.
// TODO explain better, but for now, please take a look the the example below
using ParameterVariant =
    std::variant<std::shared_ptr<Parameter<int>>, std::shared_ptr<Parameter<bool>>,
                 std::shared_ptr<Parameter<double>>,
                 std::shared_ptr<Parameter<std::string>>, std::shared_ptr<MutableConfig>>;

using ParameterList = std::vector<ParameterVariant>;

/* Config Class
 *
 * Pure virtual class used to represent a collection of
 * params and/or configs. This class does NOT expose non-const
 * functions of underlying members, and is how all plays/tactics/etc should
 * access parameters. Only the visualizer or any other part of our AI that
 * is allowed to change the values should use the MutableConfig
 */
class Config
{
   public:
    /* Pure virtual destructor */
    virtual ~Config() = 0;

    /*
     * Returns the name of the config
     *
     * returns std::string The name of the configuration
     */
    virtual std::string name() = 0;

    /*
     * Returns a const reference to the internal ParameterList
     *
     * returns const ParameterList& The parameter lists
     */
    virtual const ParameterList& getParameterList() = 0;
};

Config::~Config() {}

/*
 * Mutable Config Class
 *
 * Extends config to provide non-const functions, allows the parameter values to be
 * set to be set.
 *
 */
class MutableConfig : public Config
{
   public:
    /* Pure virtual destructor */
    virtual ~MutableConfig() = 0;

    /*
     * Returns a const reference to the internal ParameterList
     *
     * returns const ParameterList& The parameter lists
     */
    virtual ParameterList& getMutableParameterList() = 0;
};

MutableConfig::~MutableConfig() {}


///////////////////////////////////////////////////
//          AUTO-GENERATED TEST CONFGS           //
///////////////////////////////////////////////////
// These will eventually be autogenerated
// The example hierarchy:
//
// GlobalQualityConfig:
//       FriendlyEvalConfig
//           weSuck
//           weHaveNoChill
//       EnemyEvalConfig
//           enemySucks
//           enemyHasNoChill
//       everyoneSucks
//
// These are just stupid parameters/configs so you get an idea
// For now the convention is, anything that doesn't have Config at the end
// is a parameter
class FriendlyEvalConfig : public MutableConfig
{
   public:
    FriendlyEvalConfig()
    {
        we_suck_param = std::make_shared<Parameter<bool>>(
            "we_suck", "should_we_still_have_namespaces", false);
        we_have_no_chill_param = std::make_shared<Parameter<bool>>(
            "we_have_no_chill", "should_we_still_have_namespaces", false);

        internal_param_list = {we_have_no_chill_param, we_suck_param};
    }

    ~FriendlyEvalConfig() {}

    const std::shared_ptr<const Parameter<bool>> weSuck() const
    {
        return std::const_pointer_cast<const Parameter<bool>>(we_suck_param);
    }


    const std::shared_ptr<const Parameter<bool>> weHaveNoChill() const
    {
        return std::const_pointer_cast<const Parameter<bool>>(we_have_no_chill_param);
    }

    const std::shared_ptr <Parameter<bool>> weSuckMutableMutable()
    {
        return we_suck_param;
    }

    const std::shared_ptr<Parameter<bool>> weHaveNoChillMutable()
    {
        return we_have_no_chill_param;
    }

    std::string name()
    {
        return "TestConfigA";
    }

    ParameterList& getMutableParameterList()
    {
        return internal_param_list;
    }

    const ParameterList& getParameterList()
    {
        return internal_param_list;
    }

   private:
    ParameterList internal_param_list;
    std::shared_ptr<Parameter<bool>> we_suck_param;
    std::shared_ptr<Parameter<bool>> we_have_no_chill_param;
};


class EnemyEvalConfig : public MutableConfig
{
   public:
    EnemyEvalConfig()
    {
        // The parameters are initialized in the constructor
        enemy_team_sucks_param = std::make_shared<Parameter<bool>>(
            "enemy_team_sucks", "should_we_still_have_namespaces", true);
        enemy_team_has_no_chill_param = std::make_shared<Parameter<bool>>(
            "enemy_team_has_no_chill", "should_we_still_have_namespaces", true);

        internal_param_list = {enemy_team_sucks_param, enemy_team_has_no_chill_param};
    }

    ~EnemyEvalConfig() {}

    const std::shared_ptr<const Parameter<bool>> enemyTeamSucks() const
    {
        return std::const_pointer_cast<const Parameter<bool>>(enemy_team_sucks_param);
    }

    const std::shared_ptr<const Parameter<bool>> enemyTeamHasNoChill() const
    {
        return std::const_pointer_cast<const Parameter<bool>>(enemy_team_has_no_chill_param);
    }

    const std::shared_ptr<Parameter<bool>> enemyTeamSucksMutable()
    {
        return enemy_team_sucks_param;
    }

    const std::shared_ptr<Parameter<bool>> enemyTeamHasNoChillMutable()
    {
        return enemy_team_has_no_chill_param;
    }

    std::string name()
    {
        return "enemyEvalConfig";
    }

    ParameterList& getMutableParameterList()
    {
        return internal_param_list;
    }

    const ParameterList& getParameterList()
    {
        return internal_param_list;
    }

   private:
    ParameterList internal_param_list;
    std::shared_ptr<Parameter<bool>> enemy_team_sucks_param;
    std::shared_ptr<Parameter<bool>> enemy_team_has_no_chill_param;
};


class GlobalQualityConfig : public MutableConfig
{
   public:
    GlobalQualityConfig()
    {
        // The parameters are initialized in the constructor
        everyone_sucks_param = std::make_shared<Parameter<bool>>(
            "everyone_sucks", "should_we_still_have_namespaces", true);

        friendly_eval_config = std::make_shared<FriendlyEvalConfig>();
        enemy_eval_config    = std::make_shared<EnemyEvalConfig>();

        internal_param_list = {everyone_sucks_param, friendly_eval_config,
                               enemy_eval_config};
    }

    // IMMUTABLE
    const std::shared_ptr<const Parameter<bool>> everyoneSucks() const
    {
        return std::const_pointer_cast<const Parameter<bool>>(everyone_sucks_param);
    }

    const std::shared_ptr<Parameter<bool>> everyoneSucksMutable()
    {
        return everyone_sucks_param;
    }

    const std::shared_ptr<FriendlyEvalConfig> getFriendlyEvalConfigMutable()
    {
        return friendly_eval_config;
    }

    const std::shared_ptr<const FriendlyEvalConfig> getFriendlyEvalConfig() const
    {
        return std::const_pointer_cast<const FriendlyEvalConfig>(friendly_eval_config);
    }

    const std::shared_ptr<EnemyEvalConfig> getEnemyEvalConfigMutable()
    {
        return enemy_eval_config;
    }

    const std::shared_ptr<const EnemyEvalConfig> getEnemyEvalConfig() const
    {
        return std::const_pointer_cast<const EnemyEvalConfig>(enemy_eval_config);
    }

    std::string name()
    {
        return "globalQualityConfig";
    }

    ParameterList& getMutableParameterList()
    {
        return internal_param_list;
    }

    const ParameterList& getParameterList()
    {
        return internal_param_list;
    }

   private:
    ParameterList internal_param_list;
    std::shared_ptr<Parameter<bool>> everyone_sucks_param;
    std::shared_ptr<FriendlyEvalConfig> friendly_eval_config;
    std::shared_ptr<EnemyEvalConfig> enemy_eval_config;
};
