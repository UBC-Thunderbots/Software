#include "software/ai/hl/stp/play/crease_defense/crease_defense_play.h"

#include <gtest/gtest.h>

#include "software/simulated_tests/non_terminating_validation_functions/ball_in_play_or_scored_validation.h"
#include "software/simulated_tests/simulated_er_force_sim_play_test_fixture.h"
#include "software/simulated_tests/terminating_validation_functions/robot_halt_validation.h"
#include "software/simulated_tests/terminating_validation_functions/robot_in_polygon_validation.h"
#include "software/simulated_tests/validation/validation_function.h"
#include "software/test_util/test_util.h"
#include "software/time/duration.h"
#include "software/world/world.h"

class CreaseDefensePlayTest : public SimulatedErForceSimPlayTestFixture
{
   protected:
    Field field = Field::createSSLDivisionBField();
};

TEST_F(CreaseDefensePlayTest, test_defense_play)
{
    BallState ball_state(Point(0.9, 2.85), Vector(0, 0));
    auto friendly_robots = TestUtil::createStationaryRobotStatesWithId(
        {Point(-4.5, 0), Point(-3, 1.5), Point(-3, 0.5), Point(-3, -0.5), Point(-3, -1.5),
         Point(-3, -3.0)});
    setFriendlyGoalie(0);
    auto enemy_robots = TestUtil::createStationaryRobotStatesWithId({
        field.enemyGoalCenter(),
        field.enemyDefenseArea().negXNegYCorner(),
        field.enemyDefenseArea().negXPosYCorner(),
        Point(1, 3),
        Point(-1, -0.25),
        Point(-2, -1.25),
    });
    setEnemyGoalie(0);
    setAIPlayConstructor([this, ball_state]() -> std::unique_ptr<Play> {
        std::unique_ptr<CreaseDefensePlay> play =
            std::make_unique<CreaseDefensePlay>(thunderbots_config->getPlayConfig());
        play->updateControlParams(Point(1, 3));
        return play;
    });

    // We set the referee command to stop so that the robots do not kick/shoot during the
    // test
    setRefereeCommand(RefereeCommand::STOP, RefereeCommand::STOP);

    std::vector<ValidationFunction> terminating_validation_functions = {
        [](std::shared_ptr<World> world_ptr, ValidationCoroutine::push_type& yield) {
            // Wait for all robots to come to a halt
            robotHalt(world_ptr, yield);

            // Two friendly crease defenders should be close to the goalie
            Point goalie_position = world_ptr->friendlyTeam().goalie()->position();
            Rectangle crease_defender_rect(
                Point(goalie_position.x(), goalie_position.y()),
                Point(goalie_position.x() + 1.5, goalie_position.y() + 1.0));
            robotInPolygon(1, crease_defender_rect, world_ptr, yield);
            robotInPolygon(2, crease_defender_rect, world_ptr, yield);
            robotInPolygon(3, crease_defender_rect, world_ptr, yield);
        }};

    std::vector<ValidationFunction> non_terminating_validation_functions = {
        [](std::shared_ptr<World> world_ptr, ValidationCoroutine::push_type& yield) {}};

    runTest(field, ball_state, friendly_robots, enemy_robots,
            terminating_validation_functions, non_terminating_validation_functions,
            Duration::fromSeconds(10));
}
