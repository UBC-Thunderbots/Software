#include "vis_proto_deduper.h"
#include <iostream>

VisProtoDeduper::VisProtoDeduper(unsigned int window_size):
    window_size(window_size) {}

void VisProtoDeduper::dedupeAndFill(const std::vector<ObstaclePtr> &obstacle_list, TbotsProto::ObstacleList& obstacle_list_out) {
    // Lazily evit the ObstacleList from the deque
    if (sent_queue.size() > window_size) {
        const std::vector<std::size_t>& popped_hashes = sent_queue.front();
        for (const auto &obstacle_hash : popped_hashes) {
            sent_set.erase(obstacle_hash);
        }

        sent_queue.pop_front();
    }

    std::vector<std::size_t> current_hashes;
    for (const auto &obstacle : obstacle_list) {
        // TODO: may optimize later to get rid of obstacle->createObstacleProto();
        TbotsProto::Obstacle proto = obstacle->createObstacleProto();
        std::size_t hash_val = hash(proto);
        if (sent_set.count(hash_val) == 0) {
            sent_set.insert(hash_val);
            obstacle_list_out.add_obstacles()->CopyFrom(proto);
            current_hashes.push_back(hash_val);
        } else {
            // std::cout << "Duplicate" << std::endl;
        }
    }
    sent_queue.push_back(std::move(current_hashes));
}

void VisProtoDeduper::hashCombine(std::size_t &seed, std::size_t value) const {
    seed ^= value + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

// TODO: rewrite the following function generated by AI, move each hash function to each class
std::size_t VisProtoDeduper::hash(const TbotsProto::Obstacle &obstacle) const {
    std::size_t seed = 0;
    auto mix_float = [&](double val) {
        hashCombine(seed, std::hash<long long>{}(val));
    };

    if (obstacle.has_circle()) {
        hashCombine(seed, 1);
        const auto& circle = obstacle.circle();

        if (circle.has_origin()) {
            mix_float(circle.origin().x_meters());
            mix_float(circle.origin().y_meters());
        }
        mix_float(circle.radius());
    }
    else if (obstacle.has_stadium()) {
        hashCombine(seed, 2);
        const auto& stadium = obstacle.stadium();

        if (stadium.has_segment()) {
            const auto& seg = stadium.segment();
            if (seg.has_start()) {
                mix_float(seg.start().x_meters());
                mix_float(seg.start().y_meters());
            }
            if (seg.has_end()) {
                mix_float(seg.end().x_meters());
                mix_float(seg.end().y_meters());
            }
        }
        mix_float(stadium.radius());
    }
    else if (obstacle.has_polygon()) {
        hashCombine(seed, 3);
        const auto& poly = obstacle.polygon();

        for (const auto& point : poly.points()) {
            mix_float(point.x_meters());
            mix_float(point.y_meters());
        }
    }

    return seed;
}
