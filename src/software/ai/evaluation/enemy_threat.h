#pragma once

#include <optional>
#include <vector>

#include "software/world/world.h"

// This struct stores the concept of an Enemy Threat. It contains all the necessary
// information about an enemy robot and why it's threatening to the friendly team.
struct EnemyThreat
{
    // The enemy robot
    Robot robot;

    // Whether or not this robot has possession of the ball
    bool has_ball;

    // How much of the goal the enemy robot can see
    // This does not account for obstacles
    // For example, robots in the corner would have a very small angle
    // while robots directly in front of the net would have a large angle
    Angle goal_angle;

    // The largest angle the robot has to shoot on the friendly net, taking obstacles
    // into account
    std::optional<Angle> best_shot_angle;

    // The target the robot would shoot at
    std::optional<Point> best_shot_target;

    // How many passes it would take for this robot to get the ball
    // 0 - The robot already has the ball
    // 1 - The robot needs 1 pass to get the ball
    // 2 - ...etc
    int num_passes_to_get_possession;

    // The robot that would pass to this robot if necessary
    std::optional<Robot> passer;

    // Define the equality operator for this struct since one is not generated by
    // default. This is especially useful for the unit tests.
    bool operator==(const EnemyThreat &other) const
    {
        return this->robot == other.robot && this->has_ball == other.has_ball &&
               this->goal_angle == other.goal_angle &&
               this->best_shot_angle == other.best_shot_angle &&
               this->best_shot_target == other.best_shot_target &&
               this->num_passes_to_get_possession == other.num_passes_to_get_possession &&
               this->passer == other.passer;
    }
};

/**
 * Returns a map of robots that can receive a pass from a passer, and the list of
 * passers that could pass to each receiver.
 *
 * @param possible_passers Robots that could pass the ball
 * @param possible_receivers Robots that could receive the ball
 * @param all_robots All robots on the field, both friendly and enemy, including the
 * possible passers and receivers
 * @return A map of robots that can receive a pass from a passer, and the list of
 * passers that could pass to each receiver
 */
std::map<Robot, std::vector<Robot>, Robot::cmpRobotByID> findAllReceiverPasserPairs(
    const std::vector<Robot> &possible_passers,
    const std::vector<Robot> &possible_receivers, const std::vector<Robot> &all_robots);

/**
 * Returns how many passes it would take for the given passer to pass the ball to the
 * receiver so the receiver gains possession of the ball, and returns the intermediate
 * passer the receiver is most likely to receive the ball from.
 *
 * If the passing and receiving robot are the same, the number of passes is 0 and the
 * passer value is an std::nullopt. If the receiver cannot be passed to at all
 * (all passing routes are blocked), then an std::nullopt is returned
 *
 * @param initial_passer The robot the passes start from
 * @param final_receiver The robot trying to be passed to
 * @param passing_team The team the passer and receiver robots are a part of
 * @param other_team The other team (the enemy of the passing team)
 *
 * @return a pair containing the number of passes it will take for the passer robot to
 * pass the ball to the receiver robot, and the intermediate robot the receiver will
 * receive the pass from
 */
std::optional<std::pair<int, std::optional<Robot>>> getNumPassesToRobot(
    const Robot &initial_passer, const Robot &final_receiver, const Team &passing_team,
    const Team &other_team);

/**
 * Sorts the given list of threats in order of decreasing threat, so the
 * "most threatening threat" will be at the front of the vector, and the
 * "least threatening threat" will be at the end of the vector. The vector will be
 * sorted in-place.
 *
 * @param threats The given list of threats to sort in-place
 */
void sortThreatsInDecreasingOrder(std::vector<EnemyThreat> &threats);

/**
 * Calculates the threat of each enemy robot on the field, and returns them in order
 * of decreasing threat. The EnemyThreat contains information about how threatening
 * an enemy robot is to the friendly team, as well as useful information the caller
 * can use to deal with the enemy, such a which robot is may receive a pass from.
 * For example, enemies with the ball and enemies that can be passed to quickly have
 * a high threat. Enemies that do not have the ball and don't have a great view of
 * the friendly net have less threat.
 *
 * @param field The field being played on
 * @param friendly_team The friendly team
 * @param enemy_team The enemy team
 * @param ball The ball
 * @param include_goalie Whether or not to include the enemy goalie in the evaluation
 * and resultant threats
 * @return A list of EnemyThreats in order of decreasing threat
 */
std::vector<EnemyThreat> getAllEnemyThreats(const Field &field, const Team &friendly_team,
                                            Team enemy_team, const Ball &ball,
                                            bool include_goalie);
