/**
 * \defgroup ICB Inter-Chip Bus Functions
 *
 * \brief These functions manage the inter-chip bus between microcontroller and FPGA.
 *
 * The bus is used in two different ways at different times.
 * During system boot, the ICB is used to deliver a configuration bitstream to the FPGA.
 * Once the FPGA is configured, the ICB is used to communicate with the logic in the FPGA.
 *
 * In addition to the basic SPI bus which runs between the two chips, there is also an
 * interrupt wire, used during normal ICB operation. An interrupt controller in the FPGA
 * records and latches a set of edge-sensitive interrupts generated by different
 * subsystems. The current set of pending interrupts can be atomically read and cleared
 * using an ordinary command over the bus. Additionally, whenever the pending interrupt
 * set is nonempty, the separate interrupt wire is driven high. An internal task in this
 * module is notified when this happens, issues the read-and-clear command, and
 * distributes the resulting interrupt sources to their individual handlers.
 *
 * \{
 */
#include "io/icb.h"

#include <FreeRTOS.h>
#include <assert.h>
#include <crc32.h>
#include <exception.h>
#include <gpio.h>
#include <minmax.h>
#include <nvic.h>
#include <portmacro.h>
#include <rcc.h>
#include <registers/dma.h>
#include <registers/exti.h>
#include <registers/spi.h>
#include <registers/syscfg.h>
#include <semphr.h>
#include <stack.h>
#include <string.h>
#include <task.h>
#include <unused.h>

#include "io/dma.h"
#include "io/pins.h"
#include "priority.h"
#include "util/error.h"

/**
 * \internal
 *
 * \brief The DMA stream number for the SPI receive path.
 */
#define DMA_STREAM_RX 0U

/**
 * \internal
 *
 * \brief The DMA stream number for the SPI transmit path.
 */
#define DMA_STREAM_TX 3U

/**
 * \internal
 *
 * \brief The DMA channel number.
 */
#define DMA_CHANNEL 3U

/**
 * \internal
 *
 * \brief The interrupt number for the receive DMA interrupt.
 */
#define IRQ_RX_DMA NVIC_IRQ_DMA2_STREAM0

/**
 * \internal
 *
 * \brief The interrupt number for the transmit DMA interrupt.
 */
#define IRQ_TX_DMA NVIC_IRQ_DMA2_STREAM3

/**
 * \brief The possible states of a transaction.
 */
typedef enum
{
    /**
     * \brief The bus is idle.
     */
    ICB_STATE_IDLE,

    /**
     * \brief A PIO transfer is in progress.
     */
    ICB_STATE_PIO,

    /**
     * \brief A DMA transfer is in progress.
     */
    ICB_STATE_DMA,
} icb_state_t;

/**
 * \brief A block of SPI transfer.
 */
typedef struct
{
    /**
     * \brief The length of the block, in bytes.
     */
    size_t length;

    /**
     * \brief The data to transmit, or NULL to transmit all zeroes.
     */
    const void *tx;

    /**
     * \brief Where to store received data, or NULL to discard it.
     */
    void *rx;
} icb_block_t;

/**
 * \brief A byte that is always zero.
 */
static const uint8_t ZERO = 0U;

/**
 * \brief A place to store unwanted data.
 */
static uint8_t trash;

/**
 * \brief A mutex protecting the bus from multiple simultaneous accesses.
 */
static SemaphoreHandle_t bus_mutex;

/**
 * \brief A semaphore used by the ISRs to notify when a transaction is complete.
 */
static SemaphoreHandle_t transaction_complete_sem;

/**
 * \brief The semaphores to notify when ICB IRQs are asserted.
 */
static void (*irq_handlers[ICB_IRQ_COUNT])(void);

/**
 * \brief The ICB IRQ dispatching task.
 */
static TaskHandle_t irq_task_handle;

/**
 * \brief A pointer to the next block to start once the current block is done.
 */
static const icb_block_t *next_block;

/**
 * \brief The number of blocks left.
 */
static size_t blocks_left;

/**
 * \brief The working block information for the current PIO block.
 */
static icb_block_t pio_block;

/**
 * \brief The current state.
 */
static icb_state_t icb_state;

/**
 * \brief Takes the simultaneous-access mutex.
 */
static void lock_bus(void)
{
    xSemaphoreTake(bus_mutex, portMAX_DELAY);
}

/**
 * \brief Releases the simultaneous-access mutex.
 */
static void unlock_bus(void)
{
    xSemaphoreGive(bus_mutex);
}

/**
 * \brief Delays for roughly a bit time.
 */
#define sleep_bit(void)                                                                  \
    do                                                                                   \
    {                                                                                    \
        asm volatile("nop" :::);                                                         \
        asm volatile("nop" :::);                                                         \
        asm volatile("nop" :::);                                                         \
        asm volatile("nop" :::);                                                         \
    } while (0)

/**
 * \brief Starts the next block.
 *
 * This may run from a task or an ISR.
 */
static void start_next_block(void)
{
    // Sanity check.
    assert(icb_state == ICB_STATE_IDLE);

    if (blocks_left)
    {
        // Sanity check.
        assert(next_block->length);

        // Decide on PIO vs DMA.
        if (next_block->length == 1 ||
            !(!next_block->tx || dma_check(next_block->tx, next_block->length)) ||
            !(!next_block->rx || dma_check(next_block->rx, next_block->length)))
        {
            // Block is 1 byte long or refers to non-DMA-capable memory. Do
            // PIO.
            icb_state = ICB_STATE_PIO;
            pio_block = *next_block;
            ++next_block;
            --blocks_left;

            SPI_CR2_t cr2 = {
                .ERRIE = 1,
            };
            SPI1.CR2 = cr2;

            SPI_CR1_t cr1 = {
                .CPHA =
                    0,  // Capture on first clock transition, drive new data on second.
                .CPOL     = 0,  // Clock idles low.
                .MSTR     = 1,  // Master mode.
                .BR       = 0,  // Transmission speed is 84 MHz (APB2) ÷ 2 = 42 MHz.
                .SPE      = 0,  // SPI module now enabled.
                .LSBFIRST = 0,  // Most significant bit is sent first.
                .SSI = 1,  // Module should assume slave select is high → deasserted → no
                           // other master is using the bus.
                .SSM = 1,  // Module internal slave select logic is controlled by software
                           // (SSI bit).
                .RXONLY   = 0,  // Transmit and receive.
                .DFF      = 0,  // Frames are 8 bits wide.
                .CRCNEXT  = 0,  // Do not transmit a CRC now.
                .CRCEN    = 0,  // CRC calculation not used.
                .BIDIMODE = 0,  // 2-line bidirectional communication used.
            };
            SPI1.CR1 = cr1;
            cr1.SPE  = 1;
            SPI1.CR1 = cr1;

            const uint8_t *tx_ptr = pio_block.tx;
            if (tx_ptr)
            {
                pio_block.tx = tx_ptr + 1;
            }
            --pio_block.length;

            __atomic_signal_fence(__ATOMIC_SEQ_CST);

            SPI1.DR = tx_ptr ? *tx_ptr : 0;

            cr2.RXNEIE = 1;
            SPI1.CR2   = cr2;
        }
        else
        {
            // Do DMA.
            icb_state = ICB_STATE_DMA;

            // Configure transmit DMA.
            {
                _Static_assert(DMA_STREAM_TX == 3U,
                               "LIFCR needs rewriting to the proper stream number!");
                DMA_LIFCR_t lifcr = {
                    .CFEIF3  = 1U,  // Clear FIFO error interrupt flag.
                    .CDMEIF3 = 1U,  // Clear direct mode error interrupt flag.
                    .CTEIF3  = 1U,  // Clear transfer error interrupt flag.
                    .CHTIF3  = 1U,  // Clear half transfer interrupt flag.
                    .CTCIF3  = 1U,  // Clear transfer complete interrupt flag.
                };
                DMA2.LIFCR      = lifcr;
                DMA_SxFCR_t fcr = {
                    .FTH   = DMA_FIFO_THRESHOLD_HALF,  // Threshold.
                    .DMDIS = 1,                        // Use the FIFO.
                };
                DMA2.streams[DMA_STREAM_TX].FCR = fcr;
                DMA2.streams[DMA_STREAM_TX].PAR = &SPI1.DR;
                DMA2.streams[DMA_STREAM_TX].M0AR =
                    (void *)(next_block->tx
                                 ? next_block->tx
                                 : &ZERO);  // Casting away constness is safe because this
                                            // DMA stream will operate in
                                            // memory-to-peripheral mode.
                DMA2.streams[DMA_STREAM_TX].NDTR = next_block->length;
                DMA_SxCR_t scr                   = {
                    .EN     = 0,  // Disable DMA engine for now.
                    .DMEIE  = 1,  // Enable direct mode error interrupt.
                    .TEIE   = 1,  // Enable transfer error interrupt.
                    .TCIE   = 0,  // Disable transfer complete interrupt.
                    .PFCTRL = 0,  // DMA engine controls data length.
                    .DIR    = DMA_DIR_M2P,
                    .CIRC   = 0,  // No circular buffer mode.
                    .PINC   = 0,  // Do not increment peripheral address.
                    .MINC   = !!next_block->tx,  // Increment or not memory address.
                    .PSIZE  = DMA_DSIZE_BYTE,
                    .MSIZE  = DMA_DSIZE_BYTE,
                    .PINCOS = 0,  // No special peripheral address increment mode.
                    .PL     = 1,  // Priority 1 (medium).
                    .DBM    = 0,  // No double-buffer mode.
                    .CT     = 0,  // Use memory pointer zero.
                    .PBURST = DMA_BURST_SINGLE,
                    .MBURST = DMA_BURST_SINGLE,
                    .CHSEL  = DMA_CHANNEL,
                };
                DMA2.streams[DMA_STREAM_TX].CR = scr;
                scr.EN                         = 1;
                DMA2.streams[DMA_STREAM_TX].CR = scr;
            }

            // Configure receive DMA.
            {
                _Static_assert(DMA_STREAM_RX == 0U,
                               "LIFCR needs rewriting to the proper stream number!");
                DMA_LIFCR_t lifcr = {
                    .CFEIF0  = 1U,  // Clear FIFO error interrupt flag.
                    .CDMEIF0 = 1U,  // Clear direct mode error interrupt flag.
                    .CTEIF0  = 1U,  // Clear transfer error interrupt flag.
                    .CHTIF0  = 1U,  // Clear half transfer interrupt flag.
                    .CTCIF0  = 1U,  // Clear transfer complete interrupt flag.
                };
                DMA2.LIFCR      = lifcr;
                DMA_SxFCR_t fcr = {
                    .FTH   = DMA_FIFO_THRESHOLD_HALF,  // Threshold.
                    .DMDIS = 1,                        // Use the FIFO.
                };
                DMA2.streams[DMA_STREAM_RX].FCR = fcr;
                DMA2.streams[DMA_STREAM_RX].PAR = &SPI1.DR;
                DMA2.streams[DMA_STREAM_RX].M0AR =
                    next_block->rx ? next_block->rx : &trash;
                DMA2.streams[DMA_STREAM_RX].NDTR = next_block->length;
                DMA_SxCR_t scr                   = {
                    .EN     = 0,  // Disable DMA engine for now.
                    .DMEIE  = 1,  // Enable direct mode error interrupt.
                    .TEIE   = 1,  // Enable transfer error interrupt.
                    .TCIE   = 1,  // Enable transfer complete interrupt.
                    .PFCTRL = 0,  // DMA engine controls data length.
                    .DIR    = DMA_DIR_P2M,
                    .CIRC   = 0,  // No circular buffer mode.
                    .PINC   = 0,  // Do not increment peripheral address.
                    .MINC   = !!next_block->rx,  // Increment memory address.
                    .PSIZE  = DMA_DSIZE_BYTE,
                    .MSIZE  = DMA_DSIZE_BYTE,
                    .PINCOS = 0,  // No special peripheral address increment mode.
                    .PL     = 3,  // Priority 3 (very high).
                    .DBM    = 0,  // No double-buffer mode.
                    .CT     = 0,  // Use memory pointer zero.
                    .PBURST = DMA_BURST_SINGLE,
                    .MBURST = DMA_BURST_SINGLE,
                    .CHSEL  = DMA_CHANNEL,
                };
                DMA2.streams[DMA_STREAM_RX].CR = scr;
                scr.EN                         = 1;
                DMA2.streams[DMA_STREAM_RX].CR = scr;
            }

            ++next_block;
            --blocks_left;

            __atomic_signal_fence(__ATOMIC_SEQ_CST);

            SPI_CR2_t cr2 = {
                .RXDMAEN = 1,
                .TXDMAEN = 1,
                .ERRIE   = 1,
            };
            SPI1.CR2 = cr2;

            SPI_CR1_t cr1 = {
                .CPHA =
                    0,  // Capture on first clock transition, drive new data on second.
                .CPOL     = 0,  // Clock idles low.
                .MSTR     = 1,  // Master mode.
                .BR       = 0,  // Transmission speed is 84 MHz (APB2) ÷ 2 = 42 MHz.
                .SPE      = 0,  // SPI module not enabled yet.
                .LSBFIRST = 0,  // Most significant bit is sent first.
                .SSI = 1,  // Module should assume slave select is high → deasserted → no
                           // other master is using the bus.
                .SSM = 1,  // Module internal slave select logic is controlled by software
                           // (SSI bit).
                .RXONLY   = 0,  // Transmit and receive.
                .DFF      = 0,  // Frames are 8 bits wide.
                .CRCNEXT  = 0,  // Do not transmit a CRC now.
                .CRCEN    = 0,  // CRC calculation not used.
                .BIDIMODE = 0,  // 2-line bidirectional communication used.
            };
            SPI1.CR1 = cr1;
            cr1.SPE  = 1;
            SPI1.CR1 = cr1;
        }
    }
    else
    {
        // Last block finished.
        BaseType_t yield = pdFALSE;
        xSemaphoreGiveFromISR(transaction_complete_sem, &yield);
        if (yield)
        {
            portYIELD_FROM_ISR();
        }
    }
}

/**
 * \brief Shuts down a completed block.
 */
static void end_block(void)
{
    SPI_CR1_t cr1 = {0};
    SPI1.CR1      = cr1;
    SPI_CR2_t cr2 = {0};
    SPI1.CR2      = cr2;
    icb_state     = ICB_STATE_IDLE;
}

/**
 * \brief Runs a transaction.
 *
 * \param[in] blocks The blocks to run.
 * \param[in] count The number of blocks.
 */
static void transact(const icb_block_t *blocks, size_t count)
{
    // Assert chip select and wait for it to settle.
    gpio_reset(PIN_ICB_CS);
    sleep_bit();

    // If this is not an empty transaction, then transfer the data.
    if (count)
    {
        // Ensure all CPU writes to memory are observed by the DMA engine.
        __atomic_thread_fence(__ATOMIC_SEQ_CST);

        // Prepare the blocks.
        next_block  = blocks;
        blocks_left = count;

        // Start a block.
        start_next_block();

        // Wait for transaction complete.
        xSemaphoreTake(transaction_complete_sem, portMAX_DELAY);

        // Ensure all DMA transfers are observed by the CPU.
        __atomic_thread_fence(__ATOMIC_SEQ_CST);
    }

    // Wait for a final settling time and deassert chip select.
    sleep_bit();
    gpio_set(PIN_ICB_CS);
}

/**
 * \name Module initialization
 *
 * \{
 */
/**
 * \brief Initializes the ICB.
 */
void icb_init(void)
{
    // Create the FreeRTOS objects.
    static StaticSemaphore_t bus_mutex_storage, transaction_complete_sem_storage;
    bus_mutex = xSemaphoreCreateMutexStatic(&bus_mutex_storage);
    transaction_complete_sem =
        xSemaphoreCreateBinaryStatic(&transaction_complete_sem_storage);

    // Enable clock and reset module.
    rcc_enable_reset(APB2, SPI1);

    // Enable the interrupts.
    portENABLE_HW_INTERRUPT(NVIC_IRQ_EXTI0);
    portENABLE_HW_INTERRUPT(NVIC_IRQ_SPI1);
    portENABLE_HW_INTERRUPT(NVIC_IRQ_DMA2_STREAM0);
    portENABLE_HW_INTERRUPT(NVIC_IRQ_DMA2_STREAM3);
    _Static_assert(DMA_STREAM_RX == 0U,
                   "Function needs rewriting to the proper stream number!");
    _Static_assert(DMA_STREAM_TX == 3U,
                   "Function needs rewriting to the proper stream number!");
}
/**
 * \}
 */

/**
 * \name Normal communication
 *
 * These functions are used to communicate with logic in a fully configured FPGA.
 *
 * \{
 */
/**
 * \internal
 *
 * \brief Executes a microcontroller-to-FPGA ICB transaction with a parameter block.
 *
 * \param[in] command the command to request
 * \param[in] data the data block to send after the command byte as a parameter
 * \param[in] length the number of bytes in the data block to send
 */
static void icb_send_param(icb_command_t command, const void *data, size_t length)
{
    // Sanity check.
    assert(!(command & 0x80U));

    // Lock the bus.
    lock_bus();

    // Do the transaction.
    uint8_t command_byte = command;
    static uint32_t crc;
    crc = __builtin_bswap32(
        crc32_be(data, length, crc32_be(&command_byte, 1, CRC32_EMPTY)));
    const icb_block_t blocks[] = {
        {1, &command_byte, 0},
        {length, data, 0},
        {sizeof(crc), &crc, 0},
    };
    transact(blocks, sizeof(blocks) / sizeof(*blocks));

    // Unlock the bus.
    unlock_bus();
}

/**
 * \internal
 *
 * \brief Executes a microcontroller-to-FPGA ICB transaction with no parameter block.
 *
 * \param[in] command the command to request
 */
static void icb_send_nullary(icb_command_t command)
{
    // Sanity check.
    assert(!(command & 0x80U));

    // Lock the bus.
    lock_bus();

    // Do the transaction.
    static uint8_t buffer[5];
    buffer[0]    = command;
    uint32_t crc = __builtin_bswap32(crc32_be(buffer, 1, CRC32_EMPTY));
    memcpy(&buffer[1], &crc, sizeof(crc));
    const icb_block_t block = {sizeof(buffer), buffer, 0};
    transact(&block, 1);

    // Unlock the bus.
    unlock_bus();
}

/**
 * \brief Executes a microcontroller-to-FPGA ICB transaction.
 *
 * \param[in] command the command to request
 * \param[in] data the data block to send after the command byte as a parameter
 * \param[in] length the number of bytes in the data block to send
 */
void icb_send(icb_command_t command, const void *data, size_t length)
{
    if (length)
    {
        icb_send_param(command, data, length);
    }
    else
    {
        icb_send_nullary(command);
    }
}

/**
 * \brief Executes an FPGA-to-microcontroller ICB transaction.
 *
 * \param[in] command the command to request
 * \param[out] buffer the buffer into which to receive data
 * \param[in] length the number of bytes to receive
 *
 * \retval true the transaction completed successfully
 * \retval false the transaction failed due to a CRC32 error
 */
bool icb_receive(icb_command_t command, void *buffer, size_t length)
{
    // Sanity check.
    assert(command & 0x80U);
    assert(length);
    assert(dma_check(buffer, length));

    // Lock the bus.
    lock_bus();

    // Do the transaction.
    static uint8_t temp_buffer[6];
    temp_buffer[0] = command;
    uint32_t crc   = __builtin_bswap32(crc32_be(temp_buffer, 1, CRC32_EMPTY));
    memcpy(&temp_buffer[1], &crc, sizeof(crc));
    temp_buffer[5] = 0;
    static uint32_t received_crc;
    const icb_block_t blocks[] = {
        {sizeof(temp_buffer), temp_buffer, 0},
        {length, 0, buffer},
        {sizeof(received_crc), 0, &received_crc},
    };
    transact(blocks, sizeof(blocks) / sizeof(*blocks));

    // Check CRC.
    bool ok = crc32_be(buffer, length, CRC32_EMPTY) == __builtin_bswap32(received_crc);
    if (!ok)
    {
        error_et_fire(ERROR_ET_ICB_CRC);
    }

    // Unlock the bus.
    unlock_bus();

    return ok;
}
/**
 * \}
 */

/**
 * \name ICB Interrupts
 *
 * These functions handle checking and dispatching interrupts reported from the FPGA.
 *
 * \{
 */
/**
 * \brief The ICB interrupt dispatching task.
 */
static void irq_task(void *UNUSED(param))
{
    for (;;)
    {
        // If the IRQ pin is low, we have nothing to do.
        while (!gpio_get_input(PIN_ICB_IRQ))
        {
            ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        }

        // Read in the IRQ line state.
        static uint8_t status[(ICB_IRQ_COUNT + 7U) / 8U];
        icb_receive(ICB_COMMAND_GET_CLEAR_IRQS, status, sizeof(status));

        // Dispatch the IRQs.
        for (unsigned int i = 0U; i < ICB_IRQ_COUNT; ++i)
        {
            if (status[i / 8U] & (1U << (i % 8U)))
            {
                __atomic_signal_fence(__ATOMIC_ACQUIRE);
                void (*isr)(void) = __atomic_load_n(&irq_handlers[i], __ATOMIC_RELAXED);
                if (isr)
                {
                    isr();
                }
            }
        }
    }
}

/**
 * \brief Handles ICB CRC error IRQs.
 */
static void icb_crc_error_isr(void)
{
    error_et_fire(ERROR_ET_ICB_CRC);
}

/**
 * \brief Initializes the interrupt-handling subsystem.
 *
 * \pre The FPGA must already be configured.
 */
void icb_irq_init(void)
{
    // Set up a handler for the ICB CRC error IRQ.
    icb_irq_set_vector(ICB_IRQ_ICB_CRC, &icb_crc_error_isr);

    // Start the IRQ dispatching task.
    static StaticTask_t irq_task_tcb;
    STACK_ALLOCATE(irq_task_stack, 4096);
    irq_task_handle = xTaskCreateStatic(
        &irq_task, "icb-irq", sizeof(irq_task_stack) / sizeof(*irq_task_stack), 0,
        PRIO_TASK_ICB_IRQ, irq_task_stack, &irq_task_tcb);

    // Map EXTI0 to PB0.
    rcc_enable(APB2, SYSCFG);
    SYSCFG.EXTICR[0U] = (SYSCFG.EXTICR[0U] & ~(0xFU << 0U)) | (0b0001 << 0U);
    rcc_disable(APB2, SYSCFG);

    // Enable rising edge interrupts on EXTI0.
    EXTI.IMR |= 1U;
    EXTI.RTSR |= 1U;
}

/**
 * \brief Shuts down the interrupt-handling subsystem.
 */
void icb_irq_shutdown(void)
{
    // Disable rising edge interrupts on EXTI0.
    EXTI.IMR &= ~1U;
}

/**
 * \brief Sets the function that will be invoked when a particular ICB IRQ occurs.
 *
 * \param[in] irq the interrupt bit to configure
 * \param[in] isr the function to invoke when the interrupt source occurs
 */
void icb_irq_set_vector(icb_irq_t irq, void (*isr)(void))
{
    assert(irq < ICB_IRQ_COUNT);
    __atomic_signal_fence(__ATOMIC_ACQUIRE);
    __atomic_store_n(&irq_handlers[irq], isr, __ATOMIC_RELAXED);
    __atomic_signal_fence(__ATOMIC_RELEASE);
}
/**
 * \}
 */

/**
 * \name Configuration
 *
 * These functions are used to configure the FPGA.
 *
 * \{
 */
/**
 * \brief Starts the configuration process.
 *
 * \pre The ICB must have been initialized with \ref icb_init.
 *
 * \retval ICB_CONF_CONTINUE configuration can proceed by means of \ref icb_conf_block
 * \retval ICB_CONF_INIT_B_STUCK_HIGH INIT_B failed to fall when PROGRAM_B was pulled low
 * \retval ICB_CONF_INIT_B_STUCK_LOW INIT_B failed to rise after clearing configuration
 * memory \retval ICB_CONF_DONE_STUCK_HIGH DONE failed to be low for configuration
 */
icb_conf_result_t icb_conf_start(void)
{
    // Lock the bus for the entire duration of the configuration operation.
    lock_bus();

    // Float chip select, thus allowing the FPGA to drive it during configuration.
    gpio_set(PIN_ICB_CS);
    gpio_set_pupd(PIN_ICB_CS, GPIO_PUPD_PU);
    gpio_set_od(PIN_ICB_CS);

    // Force the FPGA into configuration mode by pulling PROGRAM_B low.
    gpio_reset(PIN_FPGA_PROGRAM_B);

    // Enable the SPI module.
    SPI_CR1_t cr1 = {
        .CPHA     = 0,  // Capture on first clock transition, drive new data on second.
        .CPOL     = 0,  // Clock idles low.
        .MSTR     = 1,  // Master mode.
        .BR       = 4,  // Transmission speed is 84 MHz (APB2) ÷ 32 = 2.625 MHz.
        .SPE      = 1,  // SPI module now enabled.
        .LSBFIRST = 0,  // Most significant bit is sent first.
        .SSI = 1,  // Module should assume slave select is high → deasserted → no other
                   // master is using the bus.
        .SSM =
            1,  // Module internal slave select logic is controlled by software (SSI bit).
        .RXONLY   = 0,  // Transmit and receive.
        .DFF      = 0,  // Frames are 8 bits wide.
        .CRCNEXT  = 0,  // Do not transmit a CRC now.
        .CRCEN    = 0,  // CRC calculation disabled for this transaction.
        .BIDIMODE = 0,  // 2-line bidirectional communication used.
    };
    SPI1.CR1 = cr1;

    // Wait for INIT_B to go low.
    {
        unsigned int tries = 100U / portTICK_PERIOD_MS;
        while (gpio_get_input(PIN_FPGA_INIT_B) && tries)
        {
            --tries;
            vTaskDelay(1U);
        }
        if (gpio_get_input(PIN_FPGA_INIT_B))
        {
            unlock_bus();
            return ICB_CONF_INIT_B_STUCK_HIGH;
        }
    }

    // Release PROGRAM_B.
    gpio_set(PIN_FPGA_PROGRAM_B);

    // Wait for the FPGA to clear configuration memory, sample mode pins, and set INIT_B
    // high.
    {
        unsigned int tries = 100U / portTICK_PERIOD_MS;
        while (!gpio_get_input(PIN_FPGA_INIT_B) && tries)
        {
            --tries;
            vTaskDelay(1U);
        }
        if (!gpio_get_input(PIN_FPGA_INIT_B))
        {
            unlock_bus();
            return ICB_CONF_INIT_B_STUCK_LOW;
        }
    }

    // The FPGA should have brought DONE low as it started configuration.
    if (gpio_get_input(PIN_FPGA_DONE))
    {
        unlock_bus();
        return ICB_CONF_DONE_STUCK_HIGH;
    }

    // The FPGA is now ready to receive blocks of bitstream.
    return ICB_CONF_OK;
}

/**
 * \brief Delivers a block of configuration bitstream to the FPGA.
 *
 * \pre The configuration process must have been started with \ref icb_conf_start.
 *
 * \param[in] data the block of bitstream to send
 * \param[in] length the length of the bitstream block
 */
void icb_conf_block(const void *data, size_t length)
{
    // Send the data.
    const uint8_t *data8 = data;
    while (length--)
    {
        SPI1.DR = *data8++;
        while (!SPI1.SR.TXE)
            ;
    }
}

/**
 * \brief Finishes configuring the FPGA.
 *
 * \pre All bitstream blocks must have been delivered with \ref icb_conf_block.
 *
 * \retval ICB_CONF_DONE configuration is complete
 * \retval ICB_CONF_DONE_STUCK_LOW the DONE pin failed to go high, indicating a corrupted
 * bitstream \retval ICB_CONF_CRC_ERROR the INIT_B pin went low, indicating a bitstream
 * CRC error
 */
icb_conf_result_t icb_conf_end(void)
{
    // Wait for idle bus.
    while (SPI1.SR.BSY)
        ;

    // Clear the overrun flag, which is set because we do not receive data
    // while transmitting the bitstream.
    while (SPI1.SR.RXNE)
    {
        SPI1.DR;
    }
    while (SPI1.SR.OVR)
    {
        SPI1.DR;
    }

    // Disable the SPI module.
    SPI_CR1_t cr1 = {0};
    SPI1.CR1      = cr1;

    // Unlock the bus.
    unlock_bus();

    // Wait until either DONE goes high (indicating completion) or INIT_B goes
    // low (indicating CRC error).
    TickType_t last_wake_time = xTaskGetTickCount();
    unsigned int tries        = 1000U / portTICK_PERIOD_MS;
    while (tries--)
    {
        if (!gpio_get_input(PIN_FPGA_INIT_B))
        {
            return ICB_CONF_CRC_ERROR;
        }
        if (gpio_get_input(PIN_FPGA_DONE))
        {
            // Drive chip select hard as FPGA should now have released it.
            // It was already set as output high before.
            gpio_set_pp(PIN_ICB_CS);
            gpio_set_pupd(PIN_ICB_CS, GPIO_PUPD_NONE);
            return ICB_CONF_OK;
        }
        vTaskDelayUntil(&last_wake_time, 1U);
    }

    // DONE never went high!
    return ICB_CONF_DONE_STUCK_LOW;
}
/**
 * \}
 */

/**
 * \name ISRs
 *
 * These interrupt service routines are registered in the interrupt vector table.
 *
 * \{
 */
/**
 * \brief Handles SPI 1 interrupts.
 *
 * This function should be registered in the interrupt vector table at position
 * 35.
 */
volatile SPI_SR_t checked_sr;
void spi1_isr(void)
{
    SPI_SR_t sr = SPI1.SR;
    checked_sr  = sr;
    // We disable this assertion because the old firmware will fail on it after
    // a few minutes of running, and we can't justify the time/effort to fix it
    // given that it's functional and no longer under active development. The
    // old firmware worked when built with CMake because assertions were disabled.
    // We have no idea why this is failing.
    // assert(!sr.OVR);
    assert(!sr.MODF);
    if (sr.RXNE)
    {
        assert(icb_state == ICB_STATE_PIO);
        uint8_t ch      = SPI1.DR;
        uint8_t *rx_ptr = pio_block.rx;
        if (rx_ptr)
        {
            *rx_ptr = ch;
            ++rx_ptr;
            pio_block.rx = rx_ptr;
        }
        if (pio_block.length)
        {
            assert(sr.TXE);
            const uint8_t *tx_ptr = pio_block.tx;
            if (tx_ptr)
            {
                pio_block.tx = tx_ptr + 1;
            }
            SPI1.DR = tx_ptr ? *tx_ptr : 0;
            --pio_block.length;
        }
        else
        {
            end_block();
            start_next_block();
        }
        SPI1.CR1;  // Flush APB bridge write buffer to prevent re-entry.
    }

    EXCEPTION_RETURN_BARRIER();
}

/**
 * \brief Handles DMA controller 2 stream 0 interrupts.
 *
 * This function should be registered in the interrupt vector table at position
 * 56.
 */
void dma2_stream0_isr(void)
{
    _Static_assert(DMA_STREAM_RX == 0U,
                   "Function needs rewriting to the proper stream number!");
    DMA_LISR_t lisr   = DMA2.LISR;
    DMA_LIFCR_t lifcr = {
        .CFEIF0  = lisr.FEIF0,
        .CDMEIF0 = lisr.DMEIF0,
        .CTEIF0  = lisr.TEIF0,
        .CHTIF0  = lisr.HTIF0,
        .CTCIF0  = lisr.TCIF0,
    };
    assert(!lisr.DMEIF0);
    assert(!lisr.TEIF0);
    assert(lisr.TCIF0);
    DMA2.LIFCR = lifcr;

    assert(icb_state == ICB_STATE_DMA);
    end_block();
    start_next_block();

    EXCEPTION_RETURN_BARRIER();
}

/**
 * \brief Handles DMA controller 2 stream 3 interrupts.
 *
 * This function should be registered in the interrupt vector table at position 59.
 */
void dma2_stream3_isr(void)
{
    _Static_assert(DMA_STREAM_TX == 3U,
                   "Function needs rewriting to the proper stream number!");
    abort();
}

/**
 * \brief Handles external interrupt line 0 interrupts.
 *
 * This function should be registered in the interrupt vector table at position 6.
 */
void exti0_isr(void)
{
    // Clear pending interrupt.
    EXTI.PR = 1U;

    // Give semaphore.
    BaseType_t yield = pdFALSE;
    vTaskNotifyGiveFromISR(irq_task_handle, &yield);
    if (yield)
    {
        portYIELD_FROM_ISR();
    }

    EXCEPTION_RETURN_BARRIER();
}
/**
 * \}
 */
/**
 * \}
 */
