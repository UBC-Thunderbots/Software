/**
 * \defgroup ICB Inter-Chip Bus Functions
 *
 * \brief These functions manage the inter-chip bus between microcontroller and FPGA.
 *
 * The bus is used in two different ways at different times.
 * During system boot, the ICB is used to deliver a configuration bitstream to the FPGA.
 * Once the FPGA is configured, the ICB is used to communicate with the logic in the FPGA.
 *
 * In addition to the basic SPI bus which runs between the two chips, there is also an interrupt wire, used during normal ICB operation.
 * An interrupt controller in the FPGA records and latches a set of edge-sensitive interrupts generated by different subsystems.
 * The current set of pending interrupts can be atomically read and cleared using an ordinary command over the bus.
 * Additionally, whenever the pending interrupt set is nonempty, the separate interrupt wire is driven high.
 * An internal task in this module is notified when this happens, issues the read-and-clear command, and distributes the resulting interrupt sources to their individual handlers.
 *
 * \{
 */
#include "icb.h"
#include "dma.h"
#include "error.h"
#include "pins.h"
#include "priority.h"
#include <FreeRTOS.h>
#include <assert.h>
#include <crc32.h>
#include <exception.h>
#include <gpio.h>
#include <minmax.h>
#include <nvic.h>
#include <portmacro.h>
#include <rcc.h>
#include <semphr.h>
#include <stack.h>
#include <string.h>
#include <task.h>
#include <unused.h>
#include <registers/dma.h>
#include <registers/exti.h>
#include <registers/spi.h>
#include <registers/syscfg.h>

/**
 * \internal
 *
 * \brief The DMA stream number for the SPI receive path.
 */
#define DMA_STREAM_RX 0U

/**
 * \internal
 *
 * \brief The DMA stream number for the SPI transmit path.
 */
#define DMA_STREAM_TX 3U

/**
 * \internal
 *
 * \brief The DMA channel number.
 */
#define DMA_CHANNEL 3U

/**
 * \internal
 *
 * \brief The interrupt number for the receive DMA interrupt.
 */
#define IRQ_RX_DMA NVIC_IRQ_DMA2_STREAM0

/**
 * \internal
 *
 * \brief The interrupt number for the transmit DMA interrupt.
 */
#define IRQ_TX_DMA NVIC_IRQ_DMA2_STREAM3

/**
 * \brief The possible states of a transaction.
 */
typedef enum {
	/**
	 * \brief The bus is idle.
	 */
	ICB_STATE_IDLE,

	/**
	 * \brief A PIO transfer is in progress.
	 */
	ICB_STATE_PIO,

	/**
	 * \brief A DMA transfer is in progress.
	 */
	ICB_STATE_DMA,
} icb_state_t;

/**
 * \brief A block of SPI transfer.
 */
typedef struct {
	/**
	 * \brief The length of the block, in bytes.
	 */
	size_t length;

	/**
	 * \brief The data to transmit, or NULL to transmit all zeroes.
	 */
	const void *tx;

	/**
	 * \brief Where to store received data, or NULL to discard it.
	 */
	void *rx;
} icb_block_t;

/**
 * \brief A byte that is always zero.
 */
static const uint8_t ZERO = 0U;

/**
 * \brief A place to store unwanted data.
 */
static uint8_t trash;

/**
 * \brief A mutex protecting the bus from multiple simultaneous accesses.
 */
static SemaphoreHandle_t bus_mutex;

/**
 * \brief A semaphore used by the ISRs to notify when a transaction is complete.
 */
static SemaphoreHandle_t transaction_complete_sem;

/**
 * \brief The semaphores to notify when ICB IRQs are asserted.
 */
static void (*irq_handlers[ICB_IRQ_COUNT])(void);

/**
 * \brief The ICB IRQ dispatching task.
 */
static TaskHandle_t irq_task_handle;

/**
 * \brief A pointer to the next block to start once the current block is done.
 */
static const icb_block_t *next_block;

/**
 * \brief The number of blocks left.
 */
static size_t blocks_left;

/**
 * \brief The working block information for the current PIO block.
 */
static icb_block_t pio_block;

/**
 * \brief The current state.
 */
static icb_state_t icb_state;

/**
 * \brief Takes the simultaneous-access mutex.
 */
static void lock_bus(void) {
	xSemaphoreTake(bus_mutex, portMAX_DELAY);
}

/**
 * \brief Releases the simultaneous-access mutex.
 */
static void unlock_bus(void) {
	xSemaphoreGive(bus_mutex);
}

/**
 * \brief Delays for roughly a bit time.
 */
#define sleep_bit(void) \
	do { \
		asm volatile("nop":::); \
		asm volatile("nop":::); \
		asm volatile("nop":::); \
		asm volatile("nop":::); \
	} while (0)

/**
 * \brief Starts the next block.
 *
 * This may run from a task or an ISR.
 */
static void start_next_block(void) {
	// Sanity check.
	assert(icb_state == ICB_STATE_IDLE);

	if(blocks_left) {
		// Sanity check.
		assert(next_block->length);

		// Decide on PIO vs DMA.
		if(next_block->length == 1 || !(!next_block->tx || dma_check(next_block->tx, next_block->length)) || !(!next_block->rx || dma_check(next_block->rx, next_block->length))) {
			// Block is 1 byte long or refers to non-DMA-capable memory. Do
			// PIO.
			icb_state = ICB_STATE_PIO;
			pio_block = *next_block;
			++next_block;
			--blocks_left;

			SPI_CR2_t cr2 = {
				.ERRIE = 1,
			};
			SPI1.CR2 = cr2;

			SPI_CR1_t cr1 = {
				.CPHA = 0, // Capture on first clock transition, drive new data on second.
				.CPOL = 0, // Clock idles low.
				.MSTR = 1, // Master mode.
				.BR = 0, // Transmission speed is 84 MHz (APB2) ÷ 2 = 42 MHz.
				.SPE = 0, // SPI module now enabled.
				.LSBFIRST = 0, // Most significant bit is sent first.
				.SSI = 1, // Module should assume slave select is high → deasserted → no other master is using the bus.
				.SSM = 1, // Module internal slave select logic is controlled by software (SSI bit).
				.RXONLY = 0, // Transmit and receive.
				.DFF = 0, // Frames are 8 bits wide.
				.CRCNEXT = 0, // Do not transmit a CRC now.
				.CRCEN = 0, // CRC calculation not used.
				.BIDIMODE = 0, // 2-line bidirectional communication used.
			};
			SPI1.CR1 = cr1;
			cr1.SPE = 1;
			SPI1.CR1 = cr1;

			const uint8_t *tx_ptr = pio_block.tx;
			if (tx_ptr) {
				pio_block.tx = tx_ptr + 1;
			}
			--pio_block.length;

			__atomic_signal_fence(__ATOMIC_SEQ_CST);

			SPI1.DR = tx_ptr ? *tx_ptr : 0;

			cr2.RXNEIE = 1;
			SPI1.CR2 = cr2;
		} else {
			// Do DMA.
			icb_state = ICB_STATE_DMA;

			// Configure transmit DMA.
			{
				_Static_assert(DMA_STREAM_TX == 3U, "LIFCR needs rewriting to the proper stream number!");
				DMA_LIFCR_t lifcr = {
					.CFEIF3 = 1U, // Clear FIFO error interrupt flag.
					.CDMEIF3 = 1U, // Clear direct mode error interrupt flag.
					.CTEIF3 = 1U, // Clear transfer error interrupt flag.
					.CHTIF3 = 1U, // Clear half transfer interrupt flag.
					.CTCIF3 = 1U, // Clear transfer complete interrupt flag.
				};
				DMA2.LIFCR = lifcr;
				DMA_SxFCR_t fcr = {
					.FTH = DMA_FIFO_THRESHOLD_HALF, // Threshold.
					.DMDIS = 1, // Use the FIFO.
				};
				DMA2.streams[DMA_STREAM_TX].FCR = fcr;
				DMA2.streams[DMA_STREAM_TX].PAR = &SPI1.DR;
				DMA2.streams[DMA_STREAM_TX].M0AR = (void *) (next_block->tx ? next_block->tx : &ZERO); // Casting away constness is safe because this DMA stream will operate in memory-to-peripheral mode.
				DMA2.streams[DMA_STREAM_TX].NDTR = next_block->length;
				DMA_SxCR_t scr = {
					.EN = 0, // Disable DMA engine for now.
					.DMEIE = 1, // Enable direct mode error interrupt.
					.TEIE = 1, // Enable transfer error interrupt.
					.TCIE = 0, // Disable transfer complete interrupt.
					.PFCTRL = 0, // DMA engine controls data length.
					.DIR = DMA_DIR_M2P,
					.CIRC = 0, // No circular buffer mode.
					.PINC = 0, // Do not increment peripheral address.
					.MINC = !!next_block->tx, // Increment or not memory address.
					.PSIZE = DMA_DSIZE_BYTE,
					.MSIZE = DMA_DSIZE_BYTE,
					.PINCOS = 0, // No special peripheral address increment mode.
					.PL = 1, // Priority 1 (medium).
					.DBM = 0, // No double-buffer mode.
					.CT = 0, // Use memory pointer zero.
					.PBURST = DMA_BURST_SINGLE,
					.MBURST = DMA_BURST_SINGLE,
					.CHSEL = DMA_CHANNEL,
				};
				DMA2.streams[DMA_STREAM_TX].CR = scr;
				scr.EN = 1;
				DMA2.streams[DMA_STREAM_TX].CR = scr;
			}

			// Configure receive DMA.
			{
				_Static_assert(DMA_STREAM_RX == 0U, "LIFCR needs rewriting to the proper stream number!");
				DMA_LIFCR_t lifcr = {
					.CFEIF0 = 1U, // Clear FIFO error interrupt flag.
					.CDMEIF0 = 1U, // Clear direct mode error interrupt flag.
					.CTEIF0 = 1U, // Clear transfer error interrupt flag.
					.CHTIF0 = 1U, // Clear half transfer interrupt flag.
					.CTCIF0 = 1U, // Clear transfer complete interrupt flag.
				};
				DMA2.LIFCR = lifcr;
				DMA_SxFCR_t fcr = {
					.FTH = DMA_FIFO_THRESHOLD_HALF, // Threshold.
					.DMDIS = 1, // Use the FIFO.
				};
				DMA2.streams[DMA_STREAM_RX].FCR = fcr;
				DMA2.streams[DMA_STREAM_RX].PAR = &SPI1.DR;
				DMA2.streams[DMA_STREAM_RX].M0AR = next_block->rx ? next_block->rx : &trash;
				DMA2.streams[DMA_STREAM_RX].NDTR = next_block->length;
				DMA_SxCR_t scr = {
					.EN = 0, // Disable DMA engine for now.
					.DMEIE = 1, // Enable direct mode error interrupt.
					.TEIE = 1, // Enable transfer error interrupt.
					.TCIE = 1, // Enable transfer complete interrupt.
					.PFCTRL = 0, // DMA engine controls data length.
					.DIR = DMA_DIR_P2M,
					.CIRC = 0, // No circular buffer mode.
					.PINC = 0, // Do not increment peripheral address.
					.MINC = !!next_block->rx, // Increment memory address.
					.PSIZE = DMA_DSIZE_BYTE,
					.MSIZE = DMA_DSIZE_BYTE,
					.PINCOS = 0, // No special peripheral address increment mode.
					.PL = 3, // Priority 3 (very high).
					.DBM = 0, // No double-buffer mode.
					.CT = 0, // Use memory pointer zero.
					.PBURST = DMA_BURST_SINGLE,
					.MBURST = DMA_BURST_SINGLE,
					.CHSEL = DMA_CHANNEL,
				};
				DMA2.streams[DMA_STREAM_RX].CR = scr;
				scr.EN = 1;
				DMA2.streams[DMA_STREAM_RX].CR = scr;
			}

			++next_block;
			--blocks_left;

			__atomic_signal_fence(__ATOMIC_SEQ_CST);

			SPI_CR2_t cr2 = {
				.RXDMAEN = 1,
				.TXDMAEN = 1,
				.ERRIE = 1,
			};
			SPI1.CR2 = cr2;

			SPI_CR1_t cr1 = {
				.CPHA = 0, // Capture on first clock transition, drive new data on second.
				.CPOL = 0, // Clock idles low.
				.MSTR = 1, // Master mode.
				.BR = 0, // Transmission speed is 84 MHz (APB2) ÷ 2 = 42 MHz.
				.SPE = 0, // SPI module not enabled yet.
				.LSBFIRST = 0, // Most significant bit is sent first.
				.SSI = 1, // Module should assume slave select is high → deasserted → no other master is using the bus.
				.SSM = 1, // Module internal slave select logic is controlled by software (SSI bit).
				.RXONLY = 0, // Transmit and receive.
				.DFF = 0, // Frames are 8 bits wide.
				.CRCNEXT = 0, // Do not transmit a CRC now.
				.CRCEN = 0, // CRC calculation not used.
				.BIDIMODE = 0, // 2-line bidirectional communication used.
			};
			SPI1.CR1 = cr1;
			cr1.SPE = 1;
			SPI1.CR1 = cr1;
		}
	} else {
		// Last block finished.
		BaseType_t yield = pdFALSE;
		xSemaphoreGiveFromISR(transaction_complete_sem, &yield);
		if (yield) {
			portYIELD_FROM_ISR();
		}
	}
}

/**
 * \brief Shuts down a completed block.
 */
static void end_block(void) {
	SPI_CR1_t cr1 = {0};
	SPI1.CR1 = cr1;
	SPI_CR2_t cr2 = {0};
	SPI1.CR2 = cr2;
	icb_state = ICB_STATE_IDLE;
}

/**
 * \brief Runs a transaction.
 *
 * \param[in] blocks The blocks to run.
 * \param[in] count The number of blocks.
 */
static void transact(const icb_block_t *blocks, size_t count) {
	// Assert chip select and wait for it to settle.
	gpio_reset(PIN_ICB_CS);
	sleep_bit();

	// If this is not an empty transaction, then transfer the data.
	if (count) {
		// Ensure all CPU writes to memory are observed by the DMA engine.
		__atomic_thread_fence(__ATOMIC_SEQ_CST);

		// Prepare the blocks.
		next_block = blocks;
		blocks_left = count;

		// Start a block.
		start_next_block();

		// Wait for transaction complete.
		xSemaphoreTake(transaction_complete_sem, portMAX_DELAY);

		// Ensure all DMA transfers are observed by the CPU.
		__atomic_thread_fence(__ATOMIC_SEQ_CST);
	}

	// Wait for a final settling time and deassert chip select.
	sleep_bit();
	gpio_set(PIN_ICB_CS);
}

/**
 * \name Module initialization
 *
 * \{
 */
/**
 * \brief Initializes the ICB.
 */
void icb_init(void) {
	// Create the FreeRTOS objects.
	static StaticSemaphore_t bus_mutex_storage, transaction_complete_sem_storage;
	bus_mutex = xSemaphoreCreateMutexStatic(&bus_mutex_storage);
	transaction_complete_sem = xSemaphoreCreateBinaryStatic(&transaction_complete_sem_storage);

	// Enable clock and reset module.
	rcc_enable_reset(APB2, SPI1);

	// Enable the interrupts.
	portENABLE_HW_INTERRUPT(NVIC_IRQ_EXTI0);
	portENABLE_HW_INTERRUPT(NVIC_IRQ_SPI1);
	portENABLE_HW_INTERRUPT(NVIC_IRQ_DMA2_STREAM0);
	portENABLE_HW_INTERRUPT(NVIC_IRQ_DMA2_STREAM3);
	_Static_assert(DMA_STREAM_RX == 0U, "Function needs rewriting to the proper stream number!");
	_Static_assert(DMA_STREAM_TX == 3U, "Function needs rewriting to the proper stream number!");
}
/**
 * \}
 */

/**
 * \name Normal communication
 *
 * These functions are used to communicate with logic in a fully configured FPGA.
 *
 * \{
 */
/**
 * \internal
 *
 * \brief Executes a microcontroller-to-FPGA ICB transaction with a parameter block.
 *
 * \param[in] command the command to request
 * \param[in] data the data block to send after the command byte as a parameter
 * \param[in] length the number of bytes in the data block to send
 */
static void icb_send_param(icb_command_t command, const void *data, size_t length) {
	// Sanity check.
	assert(!(command & 0x80U));

	// Lock the bus.
	lock_bus();

	// Do the transaction.
	uint8_t command_byte = command;
	static uint32_t crc;
	crc = __builtin_bswap32(crc32_be(data, length, crc32_be(&command_byte, 1, CRC32_EMPTY)));
	const icb_block_t blocks[] = {
		{ 1, &command_byte, 0 },
		{ length, data, 0 },
		{ sizeof(crc), &crc, 0 },
	};
	transact(blocks, sizeof(blocks) / sizeof(*blocks));

	// Unlock the bus.
	unlock_bus();
}

/**
 * \internal
 *
 * \brief Executes a microcontroller-to-FPGA ICB transaction with no parameter block.
 *
 * \param[in] command the command to request
 */
static void icb_send_nullary(icb_command_t command) {
	// Sanity check.
	assert(!(command & 0x80U));

	// Lock the bus.
	lock_bus();

	// Do the transaction.
	static uint8_t buffer[5];
	buffer[0] = command;
	uint32_t crc = __builtin_bswap32(crc32_be(buffer, 1, CRC32_EMPTY));
	memcpy(&buffer[1], &crc, sizeof(crc));
	const icb_block_t block = { sizeof(buffer), buffer, 0 };
	transact(&block, 1);

	// Unlock the bus.
	unlock_bus();
}

/**
 * \brief Executes a microcontroller-to-FPGA ICB transaction.
 *
 * \param[in] command the command to request
 * \param[in] data the data block to send after the command byte as a parameter
 * \param[in] length the number of bytes in the data block to send
 */
void icb_send(icb_command_t command, const void *data, size_t length) {
	if (length) {
		icb_send_param(command, data, length);
	} else {
		icb_send_nullary(command);
	}
}

/**
 * \brief Executes an FPGA-to-microcontroller ICB transaction.
 *
 * \param[in] command the command to request
 * \param[out] buffer the buffer into which to receive data
 * \param[in] length the number of bytes to receive
 *
 * \retval true the transaction completed successfully
 * \retval false the transaction failed due to a CRC32 error
 */
bool icb_receive(icb_command_t command, void *buffer, size_t length) {
	// Sanity check.
	assert(command & 0x80U);
	assert(length);
	assert(dma_check(buffer, length));

	// Lock the bus.
	lock_bus();

	// Do the transaction.
	static uint8_t temp_buffer[6];
	temp_buffer[0] = command;
	uint32_t crc = __builtin_bswap32(crc32_be(temp_buffer, 1, CRC32_EMPTY));
	memcpy(&temp_buffer[1], &crc, sizeof(crc));
	temp_buffer[5] = 0;
	static uint32_t received_crc;
	const icb_block_t blocks[] = {
		{ sizeof(temp_buffer), temp_buffer, 0 },
		{ length, 0, buffer },
		{ sizeof(received_crc), 0, &received_crc },
	};
	transact(blocks, sizeof(blocks) / sizeof(*blocks));

	// Check CRC.
	bool ok = crc32_be(buffer, length, CRC32_EMPTY) == __builtin_bswap32(received_crc);
	if (!ok) {
		error_et_fire(ERROR_ET_ICB_CRC);
	}

	// Unlock the bus.
	unlock_bus();

	return ok;
}
/**
 * \}
 */

/**
 * \name ICB Interrupts
 *
 * These functions handle checking and dispatching interrupts reported from the FPGA.
 *
 * \{
 */
/**
 * \brief The ICB interrupt dispatching task.
 */
static void irq_task(void *UNUSED(param)) {
	for (;;) {
		// If the IRQ pin is low, we have nothing to do.
		while (!gpio_get_input(PIN_ICB_IRQ)) {
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}

		// Read in the IRQ line state.
		static uint8_t status[(ICB_IRQ_COUNT + 7U) / 8U];
		icb_receive(ICB_COMMAND_GET_CLEAR_IRQS, status, sizeof(status));

		// Dispatch the IRQs.
		for (unsigned int i = 0U; i < ICB_IRQ_COUNT; ++i) {
			if (status[i / 8U] & (1U << (i % 8U))) {
				__atomic_signal_fence(__ATOMIC_ACQUIRE);
				void (*isr)(void) = __atomic_load_n(&irq_handlers[i], __ATOMIC_RELAXED);
				if (isr) {
					isr();
				}
			}
		}
	}
}

/**
 * \brief Handles ICB CRC error IRQs.
 */
static void icb_crc_error_isr(void) {
	error_et_fire(ERROR_ET_ICB_CRC);
}

/**
 * \brief Initializes the interrupt-handling subsystem.
 *
 * \pre The FPGA must already be configured.
 */
void icb_irq_init(void) {
	// Set up a handler for the ICB CRC error IRQ.
	icb_irq_set_vector(ICB_IRQ_ICB_CRC, &icb_crc_error_isr);

	// Start the IRQ dispatching task.
	static StaticTask_t irq_task_tcb;
	STACK_ALLOCATE(irq_task_stack, 4096);
	irq_task_handle = xTaskCreateStatic(&irq_task, "icb-irq", sizeof(irq_task_stack) / sizeof(*irq_task_stack), 0, PRIO_TASK_ICB_IRQ, irq_task_stack, &irq_task_tcb);

	// Map EXTI0 to PB0.
	rcc_enable(APB2, SYSCFG);
	SYSCFG.EXTICR[0U] = (SYSCFG.EXTICR[0U] & ~(0xFU << 0U)) | (0b0001 << 0U);
	rcc_disable(APB2, SYSCFG);

	// Enable rising edge interrupts on EXTI0.
	EXTI.IMR |= 1U;
	EXTI.RTSR |= 1U;
}

/**
 * \brief Shuts down the interrupt-handling subsystem.
 */
void icb_irq_shutdown(void) {
	// Disable rising edge interrupts on EXTI0.
	EXTI.IMR &= ~1U;
}

/**
 * \brief Sets the function that will be invoked when a particular ICB IRQ occurs.
 *
 * \param[in] irq the interrupt bit to configure
 * \param[in] isr the function to invoke when the interrupt source occurs
 */
void icb_irq_set_vector(icb_irq_t irq, void (*isr)(void)) {
	assert(irq < ICB_IRQ_COUNT);
	__atomic_signal_fence(__ATOMIC_ACQUIRE);
	__atomic_store_n(&irq_handlers[irq], isr, __ATOMIC_RELAXED);
	__atomic_signal_fence(__ATOMIC_RELEASE);
}
/**
 * \}
 */

/**
 * \name Configuration
 *
 * These functions are used to configure the FPGA.
 *
 * \{
 */
/**
 * \brief Starts the configuration process.
 *
 * \pre The ICB must have been initialized with \ref icb_init.
 *
 * \retval ICB_CONF_CONTINUE configuration can proceed by means of \ref icb_conf_block
 * \retval ICB_CONF_INIT_B_STUCK_HIGH INIT_B failed to fall when PROGRAM_B was pulled low
 * \retval ICB_CONF_INIT_B_STUCK_LOW INIT_B failed to rise after clearing configuration memory
 * \retval ICB_CONF_DONE_STUCK_HIGH DONE failed to be low for configuration
 */
icb_conf_result_t icb_conf_start(void) {
	// Lock the bus for the entire duration of the configuration operation.
	lock_bus();

	// Float chip select, thus allowing the FPGA to drive it during configuration.
	gpio_set(PIN_ICB_CS);
	gpio_set_pupd(PIN_ICB_CS, GPIO_PUPD_PU);
	gpio_set_od(PIN_ICB_CS);

	// Force the FPGA into configuration mode by pulling PROGRAM_B low.
	gpio_reset(PIN_FPGA_PROGRAM_B);

	// Enable the SPI module.
	SPI_CR1_t cr1 = {
		.CPHA = 0, // Capture on first clock transition, drive new data on second.
		.CPOL = 0, // Clock idles low.
		.MSTR = 1, // Master mode.
		.BR = 4, // Transmission speed is 84 MHz (APB2) ÷ 32 = 2.625 MHz.
		.SPE = 1, // SPI module now enabled.
		.LSBFIRST = 0, // Most significant bit is sent first.
		.SSI = 1, // Module should assume slave select is high → deasserted → no other master is using the bus.
		.SSM = 1, // Module internal slave select logic is controlled by software (SSI bit).
		.RXONLY = 0, // Transmit and receive.
		.DFF = 0, // Frames are 8 bits wide.
		.CRCNEXT = 0, // Do not transmit a CRC now.
		.CRCEN = 0, // CRC calculation disabled for this transaction.
		.BIDIMODE = 0, // 2-line bidirectional communication used.
	};
	SPI1.CR1 = cr1;

	// Wait for INIT_B to go low.
	{
		unsigned int tries = 100U / portTICK_PERIOD_MS;
		while (gpio_get_input(PIN_FPGA_INIT_B) && tries) {
			--tries;
			vTaskDelay(1U);
		}
		if (gpio_get_input(PIN_FPGA_INIT_B)) {
			unlock_bus();
			return ICB_CONF_INIT_B_STUCK_HIGH;
		}
	}

	// Release PROGRAM_B.
	gpio_set(PIN_FPGA_PROGRAM_B);

	// Wait for the FPGA to clear configuration memory, sample mode pins, and set INIT_B high.
	{
		unsigned int tries = 100U / portTICK_PERIOD_MS;
		while (!gpio_get_input(PIN_FPGA_INIT_B) && tries) {
			--tries;
			vTaskDelay(1U);
		}
		if (!gpio_get_input(PIN_FPGA_INIT_B)) {
			unlock_bus();
			return ICB_CONF_INIT_B_STUCK_LOW;
		}
	}

	// The FPGA should have brought DONE low as it started configuration.
	if (gpio_get_input(PIN_FPGA_DONE)) {
		unlock_bus();
		return ICB_CONF_DONE_STUCK_HIGH;
	}

	// The FPGA is now ready to receive blocks of bitstream.
	return ICB_CONF_OK;
}

/**
 * \brief Delivers a block of configuration bitstream to the FPGA.
 *
 * \pre The configuration process must have been started with \ref icb_conf_start.
 *
 * \param[in] data the block of bitstream to send
 * \param[in] length the length of the bitstream block
 */
void icb_conf_block(const void *data, size_t length) {
	// Send the data.
	const uint8_t *data8 = data;
	while (length--) {
		SPI1.DR = *data8++;
		while (!SPI1.SR.TXE);
	}
}

/**
 * \brief Finishes configuring the FPGA.
 *
 * \pre All bitstream blocks must have been delivered with \ref icb_conf_block.
 *
 * \retval ICB_CONF_DONE configuration is complete
 * \retval ICB_CONF_DONE_STUCK_LOW the DONE pin failed to go high, indicating a corrupted bitstream
 * \retval ICB_CONF_CRC_ERROR the INIT_B pin went low, indicating a bitstream CRC error
 */
icb_conf_result_t icb_conf_end(void) {
	// Wait for idle bus.
	while (SPI1.SR.BSY);

	// Clear the overrun flag, which is set because we do not receive data
	// while transmitting the bitstream.
	while (SPI1.SR.RXNE) {
		SPI1.DR;
	}
	while (SPI1.SR.OVR) {
		SPI1.DR;
	}

	// Disable the SPI module.
	SPI_CR1_t cr1 = { 0 };
	SPI1.CR1 = cr1;

	// Unlock the bus.
	unlock_bus();

	// Wait until either DONE goes high (indicating completion) or INIT_B goes
	// low (indicating CRC error).
	TickType_t last_wake_time = xTaskGetTickCount();
	unsigned int tries = 1000U / portTICK_PERIOD_MS;
	while (tries--) {
		if (!gpio_get_input(PIN_FPGA_INIT_B)) {
			return ICB_CONF_CRC_ERROR;
		}
		if (gpio_get_input(PIN_FPGA_DONE)) {
			// Drive chip select hard as FPGA should now have released it.
			// It was already set as output high before.
			gpio_set_pp(PIN_ICB_CS);
			gpio_set_pupd(PIN_ICB_CS, GPIO_PUPD_NONE);
			return ICB_CONF_OK;
		}
		vTaskDelayUntil(&last_wake_time, 1U);
	}

	// DONE never went high!
	return ICB_CONF_DONE_STUCK_LOW;
}
/**
 * \}
 */

/**
 * \name ISRs
 *
 * These interrupt service routines are registered in the interrupt vector table.
 *
 * \{
 */
/**
 * \brief Handles SPI 1 interrupts.
 *
 * This function should be registered in the interrupt vector table at position
 * 35.
 */
volatile SPI_SR_t checked_sr;
void spi1_isr(void) {
	SPI_SR_t sr = SPI1.SR;
	checked_sr = sr;
	assert(!sr.OVR);
	assert(!sr.MODF);
	if (sr.RXNE) {
		assert(icb_state == ICB_STATE_PIO);
		uint8_t ch = SPI1.DR;
		uint8_t *rx_ptr = pio_block.rx;
		if (rx_ptr) {
			*rx_ptr = ch;
			++rx_ptr;
			pio_block.rx = rx_ptr;
		}
		if (pio_block.length) {
			assert(sr.TXE);
			const uint8_t *tx_ptr = pio_block.tx;
			if (tx_ptr) {
				pio_block.tx = tx_ptr + 1;
			}
			SPI1.DR = tx_ptr ? *tx_ptr : 0;
			--pio_block.length;
		} else {
			end_block();
			start_next_block();
		}
		SPI1.CR1; // Flush APB bridge write buffer to prevent re-entry.
	}

	EXCEPTION_RETURN_BARRIER();
}

/**
 * \brief Handles DMA controller 2 stream 0 interrupts.
 *
 * This function should be registered in the interrupt vector table at position
 * 56.
 */
void dma2_stream0_isr(void) {
	_Static_assert(DMA_STREAM_RX == 0U, "Function needs rewriting to the proper stream number!");
	DMA_LISR_t lisr = DMA2.LISR;
	DMA_LIFCR_t lifcr = {
		.CFEIF0 = lisr.FEIF0,
		.CDMEIF0 = lisr.DMEIF0,
		.CTEIF0 = lisr.TEIF0,
		.CHTIF0 = lisr.HTIF0,
		.CTCIF0 = lisr.TCIF0,
	};
	assert(!lisr.DMEIF0);
	assert(!lisr.TEIF0);
	assert(lisr.TCIF0);
	DMA2.LIFCR = lifcr;

	assert(icb_state == ICB_STATE_DMA);
	end_block();
	start_next_block();

	EXCEPTION_RETURN_BARRIER();
}

/**
 * \brief Handles DMA controller 2 stream 3 interrupts.
 *
 * This function should be registered in the interrupt vector table at position 59.
 */
void dma2_stream3_isr(void) {
	_Static_assert(DMA_STREAM_TX == 3U, "Function needs rewriting to the proper stream number!");
	abort();
}

/**
 * \brief Handles external interrupt line 0 interrupts.
 *
 * This function should be registered in the interrupt vector table at position 6.
 */
void exti0_isr(void) {
	// Clear pending interrupt.
	EXTI.PR = 1U;

	// Give semaphore.
	BaseType_t yield = pdFALSE;
	vTaskNotifyGiveFromISR(irq_task_handle, &yield);
	if (yield) {
		portYIELD_FROM_ISR();
	}

	EXCEPTION_RETURN_BARRIER();
}
/**
 * \}
 */
/**
 * \}
 */
