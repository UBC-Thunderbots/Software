#!/usr/bin/env python
"""
This script runs as a preprocessor for catkin_make and
generates the necessary c++ files before compiling
to setup the DynamicParameters
"""
import yaml
import os
import time
import sys
import constants


#######################################################################
#                              Load Yaml                              #
#######################################################################

def load_configuration(path_to_yaml: str):
    """Loads the yaml files in the current directory and
    makes a dictionary containg the parameter name and its
    attributes with the proper hierarchy

    NOTE: No exception handling in place so that when an error happens
    it raises to the main thread when catkin_make runs

    :param path_to_yaml: The path to where the YAML files are stored
    :type path_to_yaml: str
    :returns: Dictionary containing the parameters with proper hierarchy
    :rtype: dict

    """
    param_info = {}

    # parse yaml and create parameter dictionaries
    for filename in os.listdir(path_to_yaml):
        if filename.endswith(".yaml"):
            with open(path_to_yaml+filename, 'r') as param_yaml:
                try:
                    param_info[filename.split(".")[0]] = yaml.load(param_yaml)
                except yaml.YAMLError as ymle:
                    error_msg = "{} could not be loaded correctly, please check format".format(
                        filename)
                    print(constants.AUTOGEN_FAILURE_MSG.format(error_msg))
                    sys.exit(error_msg)
    return param_info

#######################################################################
#                            CPP Generator                            #
#######################################################################


def generate_header_and_cpp(param_info: dict, output_path: str):
    """Takes the input dictionary from the parsed yaml
    and generates the respective cfg files needed

    :param param_info: Return value of load_configuration, dict containing params
    :param output_path: Where the cfgs should be saved to
    :type param_info: dict
    :type output_path: str

    """
    # open files
    dynamic_parameters_h = open(
        output_path+constants.DYNAMIC_PARMETERS_HEADER, 'w')
    dynamic_parameters_cpp = open(
        output_path+constants.DYNAMIC_PARMETERS_CPP, 'w')

    # write the header to .h .cpp file
    dynamic_parameters_h.write(constants.H_HEADER)
    dynamic_parameters_cpp.write(constants.CPP_HEADER)

    # generate cfg str used for topic subsription
    cfg_strs = ",".join("\"{}\"".format(key) for key in param_info.keys())
    dynamic_parameters_cpp.write(constants.CFG_STR_VECTOR.format(cfg_strs))

    # iterate through param_info starting from namespaces
    # the first key is the file name, so that is skipped
    for key, value in param_info.items():
        __header_and_cpp_gen(
            value, key, dynamic_parameters_h, dynamic_parameters_cpp)

    # append the footer
    dynamic_parameters_h.write(constants.FOOTER)
    dynamic_parameters_cpp.write(constants.FOOTER)

    # close files
    dynamic_parameters_h.close()
    dynamic_parameters_cpp.close()

    print('===== created dynamic_parameters header and cpp')


def __header_and_cpp_gen(param_info: dict, cfg_name: str, header_file_pointer, cpp_file_pointer):
    """Takes the information about the parameters and namespaces
    and recursively generates the header file, returns a string to be written
    to the file

    NOTE: Both the header and the cpp have very similar structure, so they will
    both be generated by this function

    :param param_info: Contains namespace and parameter information
        organized by filename, followed by namespaces until the parameter
    :param cfg_name: The name of the configuration file this parameter is in
    :param header_file_pointer: The file pointer to the dynamic_parameters.h file
    :param cpp_file_pointer: The file pointer to the dynamic_parameters.cpp file
    :type param_info: dict
    :type cfg_name: str
    :type header_file_pointer: file
    :type cpp_file_pointer: file

    :returns: The contents of the header file
    :rtype: str

    """
    # iterate through keys
    for key in param_info.keys():

        # if type key is found, create a parameter
        if "type" in param_info[key]:
            parameter = param_info[key]

            # write declaration to header file
            header_file_pointer.write(
                constants.H_PARAMETER_DECL.format(
                    name=key,
                    type=constants.CPP_TYPE_MAP[parameter["type"]],
                    comment=parameter["description"]
                )
            )

            # write instantiation to cpp file
            cpp_file_pointer.write(
                constants.CPP_PARAMETER_INSTNACE.format(
                    name=key,
                    path=key,
                    namespace=cfg_name,
                    # python parses "true" in the yaml as "True" and needs to be converted back to true for cpp
                    default=str(parameter["default"]).lower(
                    ) if parameter["type"] == "bool" else parameter["default"],
                    type=constants.CPP_TYPE_MAP[parameter["type"]],
                    quote="\"" if parameter["type"] in constants.QUOTE_TYPES else ""
                )
            )

        # else setup the namespaces
        else:
            # start the namespace
            header_file_pointer.write(
                constants.NAMESPACE_OPEN.format(name=key))
            cpp_file_pointer.write(constants.NAMESPACE_OPEN.format(name=key))

            __header_and_cpp_gen(
                param_info[key], cfg_name, header_file_pointer, cpp_file_pointer)

            # end the namespace
            header_file_pointer.write(constants.NAMESPACE_CLOSE)
            cpp_file_pointer.write(constants.NAMESPACE_CLOSE)


#######################################################################
#                                MAIN                                 #
#######################################################################
if __name__ == '__main__':
    # get config
    config = load_configuration(constants.PATH_TO_YAML)

    # create folders
    if not os.path.exists(constants.PATH_TO_AUTOGEN_CPP):
        os.mkdir(constants.PATH_TO_AUTOGEN_CPP)
    if not os.path.exists(constants.PATH_TO_AUTOGEN_CFG):
        os.mkdir(constants.PATH_TO_AUTOGEN_CFG)

    # generate files
    generate_header_and_cpp(config, constants.PATH_TO_AUTOGEN_CPP)
