#!/usr/bin/env python
"""
This script runs as a preprocessor for catkin_make and
generates the necessary cfg and c++ files before compiling
to setup the DynamicParameters
"""
import yaml
import os
import time
import sys

#######################################################################
#                              Constants                              #
#######################################################################
# comman constants
AUTOGEN_FAILURE_MSG = '\033[91m ======== cfg autogen failure ======== \033[0m'
PATH_TO_YAML = './config/'
PATH_TO_AUTOGEN = './autogenerated/'
PATH_TO_CPP = './'
DYNAMIC_PARMETERS_HEADER = 'dynamic_parameters.h'
DYNAMIC_PARMETERS_CPP = 'dynamic_parameters.cpp'

# cpp constants
H_HEADER = """#pragma once\n#include \"util/parameter/parameter.h\"
namespace Util\n{\nnamespace DynamicParameters\n{\n"""
CPP_HEADER = """#include \"util/parameter/dynamic_parameters.h\"\n
namespace Util\n{\nnamespace DynamicParameters\n{\n"""
FOOTER = "}\n}\n"
H_PARAMETER_DECL = 'extern Parameter<{type}> {name}; \n'
CPP_PARAMETER_INSTNACE = 'Parameter<{type}> {name}(\"{path}\", {quote}{default}{quote});\n'
NAMESPACE_OPEN = 'namespace {name} {{ \n'
NAMESPACE_CLOSE = '}\n'

CPP_TYPE_MAP = {
    "int": "int32_t",
    "double": "double",
    "string": "std::string",
    "bool": "bool",
}

# cfg contants
CFG_HEADER = """#!/usr/bin/env python
from dynamic_reconfigure.parameter_generator_catkin import *
gen = ParameterGenerator()\n"""
CFG_FOOTER = 'exit(gen.generate(\"param_server\", \"ps\", \"{}\"))'
RANGE_TYPES = ["int_t", "double_t"]
CFG_NEW_NAMESPACE = '{namespace} = gen.add_group(\"{namespace}\")\n'
CFG_SUB_NAMESPACE = '{sub_namespace} = {namespace}.add_group(\"{sub_namespace}\")\n'
CFG_PARAMETER = '{namespace}.add(\"{name}\", {type}, 0, \"{description}\", {quote}{default}{quote}, {min}, {max})\n'
EXT = '.cfg'

CFG_TYPE_MAP = {
    "int": "int_t",
    "double": "double_t",
    "string": "str_t",
    "bool": "bool_t",
}


#######################################################################
#                              Load Yaml                              #
#######################################################################

def load_configuration(path_to_yaml):
    """Loads the yaml files in the current directory and
    makes a dictionary containg the parameter name and its
    attributes with the proper heirarchy

    NOTE: No exception handling in place so that when an error happens
    it raises to the main thread when catkin_make runs

    :param path_to_yaml: The path to where the YAML files are stored
    :type path_to_yaml: str
    :returns: Dictionary containg the parameters with proper heirarchy
    :rtype: dict

    """
    param_info = {}

    # parse yaml and create parameter dictionaries
    for filename in os.listdir(path_to_yaml):
        if filename.endswith(".yaml"):
            with open(path_to_yaml+filename, 'r') as param_yaml:
                try:
                    param_info[filename.split(".")[0]] = yaml.load(param_yaml)
                except yaml.YAMLError as ymle:
                    print AUTOGEN_FAILURE_MSG
                    sys.exit(
                        "{} could not be loaded correctly, please check format".format(filename))
    return param_info

#######################################################################
#                            CFG Generator                            #
#######################################################################


def generate_cfg(param_info, output_path):
    """Takes the input dictionary from the parsed yaml
    and generates the respective cfg files needed

    :param param_info: Return value of load_configuration, dict containing params
    :param output_path: Where the cfgs should be saved to
    :type param_info: dict
    :type output_path: str

    """
    # fist key resolves to filename
    for key, value in param_info.iteritems():
        with open(output_path+key+EXT, 'w+') as fpe:

            # write boilder plate
            fpe.write(CFG_HEADER)

            # generate cfg
            __cfg_gen(param_info[key], fpe)

            # write footer
            fpe.write(CFG_FOOTER.format(key))

            # make file read/write/executable
            os.chmod(output_path+key+EXT, 0o0754)
            print '=== finished {}'.format(key)


def __cfg_gen(param_info, file_pointer, group_name=None):
    """Takes the information about parameters and namespaces,
    and recursively generates the configuration

    :param param_info: Contains namespace and parameter information
        organized by namespaces until the parameter
    :param file_pointer: The file to store the values
    :param group_name: The name of the current group to add to
    :type param_info: dict
    :type file_pointer: file
    :type group_name: str

    """
    # iterate through keys
    for key in param_info.keys():

        # if type key is found, create a parameter
        if "type" in param_info[key]:

            parameter = param_info[key]
            param_name = key
            param_type = "None"
            param_max = "None"
            param_min = "None"
            param_default = "None"
            param_description = "None"

            # setup common keys
            try:
                param_default = parameter["default"]
                param_type = CFG_TYPE_MAP[parameter["type"]]
                param_description = parameter["description"]
            except KeyError as kerr:
                print AUTOGEN_FAILURE_MSG
                sys.exit(
                    'Param {} missing one of default, type or description'.format(param_name))

            # setup min max
            try:
                param_min = parameter["min"] if param_type in RANGE_TYPES else None
                param_max = parameter["max"] if param_type in RANGE_TYPES else None
            except KeyError as kerr:
                print AUTOGEN_FAILURE_MSG
                sys.exit(
                    'Parameter {} defined as {} but does not have a min/max'.format(param_name, param_type))

            # write parameter to file
            file_pointer.write(CFG_PARAMETER.format(
                namespace=group_name,
                name=param_name,
                description=param_description,
                default=param_default,
                quote="\"" if param_type == "str_t" else "",
                type=param_type,
                min=param_min,
                max=param_min
            ))

        # if there is no current group, a new namespace must be created
        elif group_name is None:
            file_pointer.write(CFG_NEW_NAMESPACE.format(
                namespace=key
            ))
            __cfg_gen(param_info[key], file_pointer, group_name=key)

        # if there already is a group, add to that namespace
        else:
            file_pointer.write(CFG_SUB_NAMESPACE.format(
                namespace=group_name,
                sub_namespace=key
            ))
            __cfg_gen(param_info[key], file_pointer, group_name=key)


#######################################################################
#                            CPP Generator                            #
#######################################################################

def generate_header_cpp(param_info, output_path):
    """Takes the input dictionary from the parsed yaml
    and generates the respective cfg files needed

    :param param_info: Return value of load_configuration, dict containing params
    :param output_path: Where the cfgs should be saved to
    :type param_info: dict
    :type output_path: str

    """
    # write the header to .h .cpp file
    with open(output_path+DYNAMIC_PARMETERS_HEADER, 'w+') as dp_h:
        dp_h.write(H_HEADER)
    with open(output_path+DYNAMIC_PARMETERS_CPP, 'w+') as dp_cpp:
        dp_cpp.write(CPP_HEADER)

    # generate header
    dynamic_parameters_h = open(output_path+DYNAMIC_PARMETERS_HEADER, 'a')
    dynamic_parameters_cpp = open(output_path+DYNAMIC_PARMETERS_CPP, 'a')

    # iterate through param_info starting from namespaces
    # the first key is the file name, so that is skipped
    for value in param_info.itervalues():
        __header_cpp_gen(value, dynamic_parameters_h, dynamic_parameters_cpp)

    dynamic_parameters_h.close()
    dynamic_parameters_cpp.close()

    # append the footer
    with open(output_path+DYNAMIC_PARMETERS_HEADER, 'a') as dp_h:
        dp_h.write(FOOTER)
    with open(output_path+DYNAMIC_PARMETERS_CPP, 'a') as dp_cpp:
        dp_cpp.write(FOOTER)

    print'===== created header ====='


def __header_cpp_gen(param_info, header_file_pointer, cpp_file_pointer):
    """Takes the information about the parameters and namespaces
    and recursively generates the header file, returns a string to be written
    to the file

    NOTE: Both the header and the cpp have very similar structure, so they will 
    both be generated by this function

    :param param_info: Contains namespace and parameter information
        organized by filename, followed by namespaces until the parameter
    :param current_str: The current string that is being added to
    :type param_info: dict

    :returns: The contents of the header file
    :rtype: str

    """
    # iterate through keys
    for key in param_info.keys():

        # if type key is found, create a parameter
        if "type" in param_info[key]:

            # write declaration to header file
            header_file_pointer.write(H_PARAMETER_DECL.format(
                name=key,
                type=CPP_TYPE_MAP[param_info[key]["type"]]))

            # write instantiation to cpp file
            cpp_file_pointer.write(CPP_PARAMETER_INSTNACE.format(
                name=key,
                path=key,
                default=param_info[key]["default"],
                quote="\"" if param_info[key]["type"] == "string" else "",
                type=CPP_TYPE_MAP[param_info[key]["type"]]))

        # else setup the namespaces
        else:
            # start the namespace
            header_file_pointer.write(NAMESPACE_OPEN.format(name=key))
            cpp_file_pointer.write(NAMESPACE_OPEN.format(name=key))

            __header_cpp_gen(
                param_info[key], header_file_pointer, cpp_file_pointer)

            # end the namespace
            header_file_pointer.write(NAMESPACE_CLOSE)
            cpp_file_pointer.write(NAMESPACE_CLOSE)


#######################################################################
#                                MAIN                                 #
#######################################################################

config = load_configuration(PATH_TO_YAML)
__import__('pprint').pprint(config)
generate_cfg(config, PATH_TO_AUTOGEN)
generate_header_cpp(config, PATH_TO_CPP)
