
/**
 *  !! WARNING !!
 *
 *  THIS FILE IS AUTOGENERATED, ANY CHANGES MADE WILL BE LOST
 *
 *  !! WARNING !!
 */

#pragma once
#include "util/parameter/parameter.h"
namespace Util::DynamicParameters{
namespace AI { 
namespace Passing { 
// The offset from the sides of the field to place the rectangular sigmoid we use to determine what areas to pass to
extern Parameter<double> static_field_position_quality_x_offset; 

// The offset from the sides of the field to place the rectangular sigmoid we use to determine what areas to pass to
extern Parameter<double> static_field_position_quality_y_offset; 

// The weight that being close to the goal will have on the static position quality. Lower, more negative weights result in the distance to the goal having less of an effect.
extern Parameter<double> static_field_position_quality_friendly_goal_distance_weight; 

// This controls how heavily we weight a robot being near the pass receiver when calculating enemy risk to a pass
extern Parameter<double> enemy_proximity_importance; 

// The minimum open angle formed by the two enemy goal posts and the pass reception position that we think will likely result in a good shooting opportunity. Note that we may take shots below this in some cases, it's more of a weight then a cutoff.
extern Parameter<double> ideal_min_shoot_angle_degrees; 

// The minimum angle that we have to rotate after receiving a pass to shoot that we think would likely result in a goal. Note that we may try to take shots that require us to rotate more then this, it's more of a weight then a cutoff
extern Parameter<double> ideal_min_rotation_to_shoot_degrees; 

// The minimum pass speed (in m/s)
extern Parameter<double> min_pass_speed_m_per_s; 

// The maximum pass speed (in m/s)
extern Parameter<double> max_pass_speed_m_per_s; 

// Minimum time into the future at which the pass should occur. This is to ensure we have enough time to setup a robot to actually perform the pass. This is in seconds
extern Parameter<double> min_time_offset_for_pass_seconds; 

// The number of passes to try to optimize at any given time
extern Parameter<int32_t> num_passes_to_optimize; 

// The number of passes to keep after pruning
extern Parameter<int32_t> num_passes_to_keep_after_pruning; 

// The number of steps of gradient descent to perform in each iteration
extern Parameter<int32_t> number_of_gradient_descent_steps_per_iter; 

// The maximum allowed difference between the reciever and passer  point of two passes for which they are considered equal
extern Parameter<double> pass_equality_max_position_difference_meters; 

// 
extern Parameter<double> pass_equality_max_start_time_difference_seconds; 

// 
extern Parameter<double> pass_equality_max_speed_difference_meters_per_second; 

}
}
namespace Navigator { 
// asdfsadf
extern Parameter<double> default_avoid_dist; 

// 
extern Parameter<double> collision_avoid_velocity_scale; 

// 
extern Parameter<double> collision_avoid_velocity_scale2; 

}
// asdasd
extern Parameter<int32_t> robot_expiry_buffer_milliseconds; 

namespace XBoxControllerDemo { 
// The ID of the robot being controller by the XBox Controller
extern Parameter<int32_t> robot_id; 

// The robot's kick speed in meters per second
extern Parameter<double> kick_speed_meters_per_second; 

// How far in meters the robot will chip
extern Parameter<double> chip_distance_meters; 

// The RPM of the robot's dribbler when turned on
extern Parameter<int32_t> dribbler_rpm; 

// The amount to scale the x and y output values by to make the robot more or less sensitive to control linearly
extern Parameter<double> linear_sensitivity; 

// The amount to scale the theta output values to make the robot more or less sensitive to control rotationaly
extern Parameter<double> angular_sensitivity; 

}
}
