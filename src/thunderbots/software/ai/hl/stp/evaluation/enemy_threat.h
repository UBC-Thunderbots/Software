#include <optional>
#include <vector>

#include "ai/world/world.h"


namespace Evaluation
{
    // This struct stores the concept of an Enemy Threat. It contains all the necessary
    // information about an enemy robot and why it's threatening to the friendly team.
    struct EnemyThreat
    {
        // The enemy robot
        Robot robot;

        // Whether or not this robot has possession of the ball
        bool has_ball;

        // How much of the goal the enemy robot can see
        // This does not account for obstacles
        // For example, robots in the corner would have a very small angle
        // while robots directly in front of the net would have a large angle
        Angle goal_angle;

        // The largest angle the robot has to shoot on the friendly net, taking obstacles
        // into account
        std::optional<Angle> best_shot_angle;

        // The target the robot would shoot at
        std::optional<Point> best_shot_target;

        // How many passes it would take for this robot to get the ball
        // 0 - The robot already has the ball
        // 1 - The robot needs 1 pass to get the ball
        // 2 - ...etc
        int num_passes_to_get_possession;

        // The robot that would pass to this robot if necessary
        std::optional<Robot> passer;

        // Define the equality operator for this struct since one is not generated by
        // default. This is especially useful for the unit tests.
        bool operator==(const EnemyThreat &other) const
        {
            return this->robot == other.robot && this->has_ball == other.has_ball &&
                   this->goal_angle == other.goal_angle &&
                   this->best_shot_angle == other.best_shot_angle &&
                   this->best_shot_target == other.best_shot_target &&
                   this->num_passes_to_get_possession ==
                       other.num_passes_to_get_possession &&
                   this->passer == other.passer;
        }
    };

    /**
     * Returns a map of robots that can receive a pass from a passer, and the list of
     * passers that could pass to each receiver.
     *
     * @param possible_passers Robots that could pass the ball
     * @param possible_receivers Robots that could receive the ball
     * @param all_robots All robots on the field, both friendly and enemy, including the
     * possible passers and receivers
     * @return A map of robots that can receive a pass from a passer, and the list of
     * passers that could pass to each receiver
     */
    std::map<Robot, std::vector<Robot>, Robot::cmpRobotByID> findAllReceiverPasserPairs(
        const std::vector<Robot> &possible_passers,
        const std::vector<Robot> &possible_receivers,
        const std::vector<Robot> &all_robots);

    /**
     * Returns how many passes it would take for the given passer to pass the ball to the
     * receiver so the receiver gains possession of the ball, and returns the intermediate
     * passer the receiver is most likely to receive the ball from.
     *
     * If the passing and receiving robot are the same, the number of passes is 0 and the
     * passer value is an std::nullopt. If the receiver cannot be passed to at all
     * (all passing routes are blocked), then an std::nullopt is returned
     *
     * @param initial_passer The robot the passes start from
     * @param final_receiver The robot trying to be passed to
     * @param passing_team The team the passer and receiver robots are a part of
     * @param other_team The other team (the enemy of the passing team)
     *
     * @return a pair containing the number of passes it will take for the passer robot to
     * pass the ball to the receiver robot, and the intermediate robot the receiver will
     * receive the pass from
     */
    std::optional<std::pair<int, std::optional<Robot>>> getNumPassesToRobot(
        const Robot &initial_passer, const Robot &final_receiver,
        const Team &passing_team, const Team &other_team);

    /**
     * Sorts the given list of threats in order of decreasing threat, so the
     * "most threatening threat" will be at the front of the vector, and the
     * "least threatening threat" will be at the end of the vector. The vector will be
     * sorted in-place.
     *
     * @param threats The given list of threats to sort in-place
     */
    void sortThreatsInDecreasingOrder(std::vector<Evaluation::EnemyThreat> &threats);

    /**
     * Calculates the threat of each enemy robot on the field, and returns them in order
     * of decreasing threat. The EnemyThreat contains information about how threatening
     * an enemy robot is to the friendly team, as well as useful information the caller
     * can use to deal with the enemy, such a which robot is may receive a pass from.
     * For example, enemies with the ball and enemies that can be passed to quickly have
     * a high threat. Enemies that do not have the ball and don't have a great view of
     * the friendly net have less threat.
     *
     * @param field The field being played on
     * @param friendly_team The friendly team
     * @param enemy_team The enemy team
     * @param ball The ball
     * @return A list of EnemyThreats in order of decreasing threat
     */
    std::vector<Evaluation::EnemyThreat> getAllEnemyThreats(const Field &field,
                                                            const Team &friendly_team,
                                                            const Team &enemy_team,
                                                            const Ball &ball);

}  // namespace Evaluation
